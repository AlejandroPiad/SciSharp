%==================================================
%--------------------------------------------------
    \typedef{ScientificTools.AssertFailedException}{ScientificTools.AssertFailedException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{Exception}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Benchmarks.Benchmark}{ScientificTools.Benchmarks.Benchmark}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Benchmarks.Benchmark}{GetEnumerator}()
        \item[] \code{Void}  \methoddef{ScientificTools.Benchmarks.Benchmark}{Run}()
        \item[] \code{Void}  \methoddef{ScientificTools.Benchmarks.Benchmark}{Run}(\code{TextWriter} \code{log})
        \item[] \code{String}  \methoddef{ScientificTools.Benchmarks.Benchmark}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Benchmarks.BenchmarkCollection}{ScientificTools.Benchmarks.BenchmarkCollection}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Benchmarks.BenchmarkCollection}{Add}(\code{String} \code{name}, \typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{minimun}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
        \item[] \code{Void}  \methoddef{ScientificTools.Benchmarks.BenchmarkCollection}{Add}(\typeref{BenchmarkFunction}{ScientificTools.Benchmarks.BenchmarkFunction} \code{benchmarkData})
        \item[] \typeref{Benchmark}{ScientificTools.Benchmarks.Benchmark}  \methoddef{ScientificTools.Benchmarks.BenchmarkCollection}{Apply}(\typeref{IOptimizer}{ScientificTools.Optimization.IOptimizer} \code{optimizer})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Benchmarks.BenchmarkEventArgs}{ScientificTools.Benchmarks.BenchmarkEventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{EventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{BenchmarkEventArgs}{CurrentPoint} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{BenchmarkEventArgs}{CurrentValue} \code{\{ get; set \}}
        \item[] \typeref{BenchmarkFunction}{ScientificTools.Benchmarks.BenchmarkFunction} \propertydef{BenchmarkEventArgs}{Function} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Benchmarks.BenchmarkFunction}{ScientificTools.Benchmarks.BenchmarkFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{BenchmarkFunction}{Dimension} \code{\{ get; \}}
        \item[] \typeref{IRealFunction}{ScientificTools.IRealFunction} \propertydef{BenchmarkFunction}{Function} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{BenchmarkFunction}{Minimun} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{BenchmarkFunction}{MinimunValue} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{BenchmarkFunction}{StartingPoint} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Double}  \methoddef{ScientificTools.Benchmarks.BenchmarkFunction}{Value}(\typeref{Vector}{ScientificTools.Vector} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Benchmarks.BenchmarkResult}{ScientificTools.Benchmarks.BenchmarkResult}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{BenchmarkResult}{Error} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{BenchmarkResult}{Evaluations} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{BenchmarkResult}{Minimun} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{BenchmarkResult}{MinimunValue} \code{\{ get; \}}
        \item[] \code{String} \propertydef{BenchmarkResult}{Name} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{BenchmarkResult}{UserMinimun} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{BenchmarkResult}{UserValue} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Benchmarks.BenchmarkResult}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.AdaboostClassifier<T>}{ScientificTools.Classification.AdaboostClassifier`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.AdaboostClassifier`1}{Add}(\typeref{IClassifier<T,TClass>}{} \code{classifier})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Classification.AdaboostClassifier`1}{Classify}(\typeref{T}{} \code{item})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Classification.AdaboostClassifier`1}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.ClassifiedItem<TItem,TClass>}{ScientificTools.Classification.ClassifiedItem`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{TClass}{} \propertydef{ClassifiedItem`2}{Class} \code{\{ get; \}}
        \item[] \typeref{TItem}{} \propertydef{ClassifiedItem`2}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.Classifiers}{ScientificTools.Classification.Classifiers}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{ClassifiedItem<TItem,TClass>}{}  \methoddef{ScientificTools.Classification.Classifiers}{ClassifyItem}(\typeref{IClassifier<T,TClass>}{} \code{classifier}, \typeref{TItem}{} \code{item})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Classification.Classifiers}{ClassifyMany}(\typeref{IClassifier<T,TClass>}{} \code{classifier}, \code{IEnumerable<T>} \code{items})
        \item[] \typeref{IClassifier<T,TClass>}{}  \methoddef{ScientificTools.Classification.Classifiers}{FromMethod}(\code{Func<T,TResult>} \code{classification})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.ClassifiersCommitee<T,TClass>}{ScientificTools.Classification.ClassifiersCommitee`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.ClassifiersCommitee`2}{Add}(\typeref{IClassifier<T,TClass>}{} \code{classifier})
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.ClassifiersCommitee`2}{Add}(\typeref{IClassifier<T,TClass>}{} \code{classifier}, \code{Double} \code{weight})
        \item[] \typeref{TClass}{}  \methoddef{ScientificTools.Classification.ClassifiersCommitee`2}{Classify}(\typeref{T}{} \code{item})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Classification.ClassifiersCommitee`2}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.FeatureClassifier<T,TFeature,TClass>}{ScientificTools.Classification.FeatureClassifier`3}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{FeatureClassifier`3}{Classes} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TClass}{}  \methoddef{ScientificTools.Classification.FeatureClassifier`3}{Classify}(\typeref{T}{} \code{item})
        \item[] \code{Int32}  \methoddef{ScientificTools.Classification.FeatureClassifier`3}{Count}(\typeref{TClass}{} \code{featureClass}, \typeref{TFeature}{} \code{feature})
        \item[] \code{Int32}  \methoddef{ScientificTools.Classification.FeatureClassifier`3}{FeatureCount}(\typeref{TFeature}{} \code{feature})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Classification.FeatureClassifier`3}{GetFeatures}(\typeref{T}{} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.FeatureClassifier`3}{Train}(\typeref{TFeature}{} \code{feature}, \typeref{TClass}{} \code{itemClass})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.FeatureCount<TFeature>}{ScientificTools.Classification.FeatureCount`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{FeatureCount`1}{Count} \code{\{ get; \}}
        \item[] \typeref{TFeature}{} \propertydef{FeatureCount`1}{Feature} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.FeatureExtraction<T,TFeature>}{ScientificTools.Classification.FeatureExtraction`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Classification.FeatureExtraction`2}{BeginInvoke}(\typeref{T}{} \code{item}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Classification.FeatureExtraction`2}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Classification.FeatureExtraction`2}{Invoke}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.FeatureTrainer<T,TFeature,TClass,TClassifier>}{ScientificTools.Classification.FeatureTrainer`4}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TClassifier}{}  \methoddef{ScientificTools.Classification.FeatureTrainer`4}{Train}(\code{IEnumerable<T>} \code{trainingSet})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.IClassifier<T,TClass>}{ScientificTools.Classification.IClassifier`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TClass}{}  \methoddef{ScientificTools.Classification.IClassifier`2}{Classify}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.ITrainer<T,TClass,TClassifier>}{ScientificTools.Classification.ITrainer`3}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TClassifier}{}  \methoddef{ScientificTools.Classification.ITrainer`3}{Train}(\code{IEnumerable<T>} \code{trainingSet})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.NaiveBayesClassifier<T,TFeature,TClass>}{ScientificTools.Classification.NaiveBayesClassifier`3}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{FeatureClassifier<T,TFeature,TClass>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Classification.NaiveBayesClassifier`3}{GetFeatures}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Matrix[]}{ScientificTools.Matrix[]} \propertydef{FeedFowardNetwork}{Weights} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}{Feed}(\typeref{Vector}{ScientificTools.Vector} \code{input})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}{Feed}(\typeref{Matrix}{ScientificTools.Matrix} \code{input})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}{Test}(\code{IEnumerable<T>} \code{examples})
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.NeuralNetworks.FeedFowardNetwork}{Train}(\code{IEnumerable<T>} \code{trainingExamples}, \code{Int32} \code{epochs}, \code{Int32} \code{batchSize}, \code{Double} \code{minError})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.NeuralNetworks.TrainingExample}{ScientificTools.Classification.NeuralNetworks.TrainingExample}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{TrainingExample}{Input} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{TrainingExample}{InputSize} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{TrainingExample}{Output} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{TrainingExample}{OutputSize} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.TrainingResult<TClass>}{ScientificTools.Classification.TrainingResult`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{TrainingResult`1}{Correct} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{TrainingResult`1}{Effectiveness} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{TrainingResult`1}{TotalItems} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{TrainingResult`1}{Wrong} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.TrainingResult`1}{Add}(\typeref{TClass}{} \code{realClass}, \typeref{TClass}{} \code{classifiedClass})
        \item[] \code{Int32}  \methoddef{ScientificTools.Classification.TrainingResult`1}{CrossClassification}(\typeref{TClass}{} \code{realClass}, \typeref{TClass}{} \code{classifiedClass})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Classification.TrainingSet<T,TClass>}{ScientificTools.Classification.TrainingSet`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.TrainingSet`2}{Add}(\typeref{ClassifiedItem<TItem,TClass>}{} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Classification.TrainingSet`2}{Add}(\typeref{T}{} \code{item}, \typeref{TClass}{} \code{itemClass})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Classification.TrainingSet`2}{GetEnumerator}()
        \item[] \typeref{TrainingSet<T,TClass>}{ScientificTools.Classification.TrainingSet`2}  \methoddef{ScientificTools.Classification.TrainingSet`2}{Partition}(\code{Int32} \code{count})
        \item[] \typeref{TrainingResult<TClass>}{}  \methoddef{ScientificTools.Classification.TrainingSet`2}{Test}(\typeref{IClassifier<T,TClass>}{} \code{classifier})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.ClustersBase<T>}{ScientificTools.Clustering.ClustersBase`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ClustersBase`1}{Clusters} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Clustering.ClustersBase`1}{ClusterOf}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.IClusterer<T>}{ScientificTools.Clustering.IClusterer`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IClusters<T>}{}  \methoddef{ScientificTools.Clustering.IClusterer`1}{Run}(\code{IEnumerable<T>} \code{items}, \code{Func<T1,T2,TResult>} \code{distance})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.IClusters<T>}{ScientificTools.Clustering.IClusters`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IClusters`1}{Clusters} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Clustering.IClusters`1}{ClusterOf}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.IFixedClusterer<T>}{ScientificTools.Clustering.IFixedClusterer`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IClusters<T>}{}  \methoddef{ScientificTools.Clustering.IFixedClusterer`1}{Run}(\code{IEnumerable<T>} \code{items}, \code{Func<T1,T2,TResult>} \code{distance}, \code{Int32} \code{clusters})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.KMeansClusterer<T>}{ScientificTools.Clustering.KMeansClusterer`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{KMeansClusterer`1}{IterationsPerCluster} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IClusters<T>}{}  \methoddef{ScientificTools.Clustering.KMeansClusterer`1}{Run}(\code{IEnumerable<T>} \code{items}, \code{Func<T1,T2,TResult>} \code{distance}, \code{Int32} \code{clusters})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Clustering.KMeansClusters<T>}{ScientificTools.Clustering.KMeansClusters`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{KMeansClusters`1}{Clusters} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Clustering.KMeansClusters`1}{Classify}(\typeref{T}{} \code{item})
        \item[] \code{Int32}  \methoddef{ScientificTools.Clustering.KMeansClusters`1}{ClusterOf}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Arrays}{ScientificTools.Collections.Arrays}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Collections.Arrays}{Fill}(\code{Int32} \code{length})
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Collections.Arrays}{Fill}(\typeref{T}{} \code{value}, \code{Int32} \code{length})
        \item[] \typeref{ArraySlice<T>}{}  \methoddef{ScientificTools.Collections.Arrays}{Slice}(\typeref{T[]}{} \code{array}, \code{Int32} \code{start}, \code{Int32} \code{step}, \code{Int32} \code{end})
        \item[] \typeref{ArraySlice<T>}{}  \methoddef{ScientificTools.Collections.Arrays}{Slice}(\typeref{T[]}{} \code{array}, \code{Int32} \code{start}, \code{Int32} \code{end})
        \item[] \typeref{ArraySlice<T>}{}  \methoddef{ScientificTools.Collections.Arrays}{Slice}(\typeref{T[]}{} \code{array})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.Arrays}{Swap}(\typeref{T[]}{} \code{array}, \code{Int32} \code{i}, \code{Int32} \code{j})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.ArraySet<T>}{ScientificTools.Collections.ArraySet`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{FiniteSetBase<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ArraySet`1}{Count} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ArraySet`1}{Contains}(\typeref{T}{} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ArraySet`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ArraySet`1}{Equals}(\typeref{ArraySet<T>}{ScientificTools.Collections.ArraySet`1} \code{other})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.ArraySet`1}{GetEnumerator}()
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.ArraySet`1}{GetHashCode}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ArraySlice`1}{Count} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{ArraySlice`1}{Item} \code{\{ get; set \}}
        \item[] \typeref{ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1} \propertydef{ArraySlice`1}{Item} \code{\{ get; set \}}
        \item[] \typeref{ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1} \propertydef{ArraySlice`1}{Item} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ArraySlice`1}{Contains}(\typeref{T}{} \code{item})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.ArraySlice`1}{GetEnumerator}()
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Collections.ArraySlice`1}{ToArray}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.AvlDictionary<TKey,TValue>}{ScientificTools.Collections.AvlDictionary`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{AvlDictionary`2}{Count} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{AvlDictionary`2}{IsReadOnly} \code{\{ get; \}}
        \item[] \typeref{TValue}{} \propertydef{AvlDictionary`2}{Item} \code{\{ get; set \}}
        \item[] \code{ICollection<T>} \propertydef{AvlDictionary`2}{Keys} \code{\{ get; set \}}
        \item[] \code{ICollection<T>} \propertydef{AvlDictionary`2}{Values} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Add}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Add}(\typeref{TKey}{} \code{key}, \typeref{TValue}{} \code{value})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Clear}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Contains}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{ContainsKey}(\typeref{TKey}{} \code{key})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{CopyTo}(\code{KeyValuePair`2<TKey,TValue>} \code{array}, \code{Int32} \code{arrayIndex})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{GetEnumerator}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Remove}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{Remove}(\typeref{TKey}{} \code{key})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlDictionary`2}{TryGetValue}(\typeref{TKey}{} \code{key}, \typeref{TValue}{} \code{value})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.AvlTree<T>}{ScientificTools.Collections.AvlTree`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{AvlTree`1}{Count} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{AvlTree`1}{Height} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{AvlTree`1}{IsReadOnly} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{AvlTree`1}{Max} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{AvlTree`1}{Min} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlTree`1}{Add}(\typeref{T}{} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlTree`1}{Clear}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlTree`1}{Contains}(\typeref{T}{} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.AvlTree`1}{CopyTo}(\typeref{T[]}{} \code{array}, \code{Int32} \code{arrayIndex})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.AvlTree`1}{GetEnumerator}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlTree`1}{Remove}(\typeref{T}{} \code{item})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.AvlTree`1}{RemoveMax}()
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.AvlTree`1}{RemoveMin}()
        \item[] \code{String}  \methoddef{ScientificTools.Collections.AvlTree`1}{ToString}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.AvlTree`1}{TryAdd}(\typeref{T}{} \code{value})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.BinaryHeap<T>}{ScientificTools.Collections.BinaryHeap`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{BinaryHeap`1}{Count} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{BinaryHeap`1}{Empty} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{BinaryHeap`1}{Min} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.BinaryHeap`1}{Add}(\typeref{T}{} \code{item})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.BinaryHeap`1}{Extract}()
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.BinaryHeap`1}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Combinatorics}{ScientificTools.Collections.Combinatorics}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Combinations}(\code{IEnumerable<T>} \code{set})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{Variations}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Combinatorics}{VariationsWithRepetition}(\code{IEnumerable<T>} \code{set}, \code{Int32} \code{size}, \code{Predicate<T>} \code{elementFilter}, \code{Predicate<T>} \code{subsetFilter})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.DefaultDictionary<TKey,TValue>}{ScientificTools.Collections.DefaultDictionary`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{DefaultDictionary`2}{AddOnGet} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{DefaultDictionary`2}{Count} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{DefaultDictionary`2}{IsReadOnly} \code{\{ get; \}}
        \item[] \typeref{TValue}{} \propertydef{DefaultDictionary`2}{Item} \code{\{ get; set \}}
        \item[] \code{ICollection<T>} \propertydef{DefaultDictionary`2}{Keys} \code{\{ get; \}}
        \item[] \code{ICollection<T>} \propertydef{DefaultDictionary`2}{Values} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Add}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Add}(\typeref{TKey}{} \code{key}, \typeref{TValue}{} \code{value})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Clear}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Contains}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{ContainsKey}(\typeref{TKey}{} \code{key})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{CopyTo}(\code{KeyValuePair`2<TKey,TValue>} \code{array}, \code{Int32} \code{arrayIndex})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{GetEnumerator}()
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Internal}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Remove}(\code{KeyValuePair<TKey,TValue>} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{Remove}(\typeref{TKey}{} \code{key})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.DefaultDictionary`2}{TryGetValue}(\typeref{TKey}{} \code{key}, \typeref{TValue}{} \code{value})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Dictionaries}{ScientificTools.Collections.Dictionaries}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TValue}{}  \methoddef{ScientificTools.Collections.Dictionaries}{Get}(\code{IDictionary<TKey,TValue>} \code{dictionary}, \typeref{TKey}{} \code{key}, \typeref{TValue}{} \code{defaultValue}, \code{Boolean} \code{add})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.DimensionStrategies}{ScientificTools.Collections.DimensionStrategies}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{DimensionStrategy}{ScientificTools.Collections.DimensionStrategy}  \methoddef{ScientificTools.Collections.DimensionStrategies}{Cyclic}(\code{Int32} \code{length})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.DimensionStrategies}{Longest}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.DimensionStrategy}{ScientificTools.Collections.DimensionStrategy}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Collections.DimensionStrategy}{BeginInvoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.DimensionStrategy}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.DimensionStrategy}{Invoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Edge<TNode>}{ScientificTools.Collections.Edge`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{TNode}{} \propertydef{Edge`1}{Left} \code{\{ get; set \}}
        \item[] \typeref{TNode}{} \propertydef{Edge`1}{Right} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.Edge`1}{Equals}(\typeref{Edge<TNode>}{ScientificTools.Collections.Edge`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.Edge`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.Edge`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Collections.Edge`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.ElementSet<T>}{ScientificTools.Collections.ElementSet`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{FiniteSetBase<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ElementSet`1}{Count} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ElementSet`1}{Contains}(\typeref{T}{} \code{item})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.ElementSet`1}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.FiniteSetBase<T>}{ScientificTools.Collections.FiniteSetBase`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{FiniteSetBase`1}{Count} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.FiniteSetBase`1}{Contains}(\typeref{T}{} \code{item})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.FiniteSetBase`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.FiniteSetBase`1}{GetEnumerator}()
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Collections.FiniteSetBase`1}{ToArray}()
        \item[] \code{String}  \methoddef{ScientificTools.Collections.FiniteSetBase`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Graphs}{ScientificTools.Collections.Graphs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IGraph<TNode,TEdge>}{}  \methoddef{ScientificTools.Collections.Graphs}{AsWeighted}(\typeref{IGraph<T>}{} \code{graph})
        \item[] \typeref{IGraph<TNode,TEdge>}{}  \methoddef{ScientificTools.Collections.Graphs}{AsWeighted}(\typeref{IGraph<T>}{} \code{graph}, \code{Func<T,TResult>} \code{edgeWeight})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Graphs.WeightedGraph<T>}{ScientificTools.Collections.Graphs+WeightedGraph`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{WeightedEdge<TNode>}{} \propertydef{WeightedGraph`1}{Item} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Graphs+WeightedGraph`1}{AdyacentOf}(\typeref{T}{} \code{node})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.Graphs+WeightedGraph`1}{Degree}(\typeref{T}{} \code{node})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IBinaryTree<T>}{ScientificTools.Collections.IBinaryTree`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IBinaryTree<T>}{ScientificTools.Collections.IBinaryTree`1} \propertydef{IBinaryTree`1}{Left} \code{\{ get; \}}
        \item[] \typeref{IBinaryTree<T>}{ScientificTools.Collections.IBinaryTree`1} \propertydef{IBinaryTree`1}{Right} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IDirectedGraph<TNode,TEdge>}{ScientificTools.Collections.IDirectedGraph`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.IDirectedGraph`2}{InNeighboors}(\typeref{TNode}{} \code{node})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.IDirectedGraph`2}{OutNeighboors}(\typeref{TNode}{} \code{node})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IEnumerableSet<T>}{ScientificTools.Collections.IEnumerableSet`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IFiniteSet`1}{Count} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Collections.IFiniteSet`1}{ToArray}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IGraph<T>}{ScientificTools.Collections.IGraph`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IGraph<TNode,TEdge>}{ScientificTools.Collections.IGraph`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{TEdge}{} \propertydef{IGraph`2}{Item} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.IGraph`2}{AdyacentOf}(\typeref{TNode}{} \code{node})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.IGraph`2}{Degree}(\typeref{TNode}{} \code{node})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IQueue<T>}{ScientificTools.Collections.IQueue`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IQueue`1}{Count} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.IQueue`1}{Dequeue}()
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.IQueue`1}{Enqueue}(\typeref{T}{} \code{item})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.IQueue`1}{Peek}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.ISet<T>}{ScientificTools.Collections.ISet`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.ISet`1}{Contains}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.IStack<T>}{ScientificTools.Collections.IStack`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IStack`1}{Count} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{IStack`1}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.IStack`1}{Clear}()
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.IStack`1}{Pop}()
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.IStack`1}{Push}(\typeref{T}{} \code{item})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.IStack`1}{Top}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.ITree<T>}{ScientificTools.Collections.ITree`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{IEnumerable<T>} \propertydef{ITree`1}{Children} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{ITree`1}{Value} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.KdTree}{ScientificTools.Collections.KdTree}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{KdTree}{Count} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{KdTree}{Depth} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{KdTree}{ParallelOptimizations} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{KdTree}{ScientificTools.Collections.KdTree}  \methoddef{ScientificTools.Collections.KdTree}{Build}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \typeref{PartitionStrategy}{ScientificTools.Collections.PartitionStrategy} \code{partitionStrategy}, \typeref{DimensionStrategy}{ScientificTools.Collections.DimensionStrategy} \code{pickingStrategy}, \code{Single} \code{epsilon})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.KdTree}{Closest}(\typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{Single} \code{maxDist})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.KdTree}{Closest}(\code{Int32} \code{count}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{Single} \code{maxDist})
        \item[] \code{String}  \methoddef{ScientificTools.Collections.KdTree}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.KdTree.KdNode}{ScientificTools.Collections.KdTree+KdNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{KdNode}{IsLeaf} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.KdTree+KdNode}{Closest}(\code{Int32} \code{count}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{Single} \code{maxDist})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.PartitionStrategies}{ScientificTools.Collections.PartitionStrategies}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.PartitionStrategies}{Median}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right}, \code{Int32} \code{dimension})
        \item[] \typeref{PartitionStrategy}{ScientificTools.Collections.PartitionStrategy}  \methoddef{ScientificTools.Collections.PartitionStrategies}{RandomMedian}(\code{Int32} \code{samples})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.PartitionStrategy}{ScientificTools.Collections.PartitionStrategy}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Collections.PartitionStrategy}{BeginInvoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right}, \code{Int32} \code{dimension}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.PartitionStrategy}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.PartitionStrategy}{Invoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors}, \code{Int32} \code{left}, \code{Int32} \code{right}, \code{Int32} \code{dimension})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.RandomizedHeap<T>}{ScientificTools.Collections.RandomizedHeap`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RandomizedHeap`1}{Count} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{Add}(\typeref{T}{} \code{item})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{GetEnumerator}()
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{Merge}(\typeref{RandomizedHeap<T>}{ScientificTools.Collections.RandomizedHeap`1} \code{other})
        \item[] \typeref{RandomizedHeap<T>}{ScientificTools.Collections.RandomizedHeap`1}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{Merge}(\typeref{RandomizedHeap<T>}{ScientificTools.Collections.RandomizedHeap`1} \code{left}, \typeref{RandomizedHeap<T>}{ScientificTools.Collections.RandomizedHeap`1} \code{right})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{Peek}()
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Collections.RandomizedHeap`1}{Pop}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.RandomSet}{ScientificTools.Collections.RandomSet}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.RandomSet}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.RangeSet}{ScientificTools.Collections.RangeSet}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RangeSet}{Count} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{RangeSet}{IsReadOnly} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.RangeSet}{Add}(\code{Int32} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.RangeSet}{Clear}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.RangeSet}{Contains}(\code{Int32} \code{item})
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.RangeSet}{CopyTo}(\code{Int32[]} \code{array}, \code{Int32} \code{arrayIndex})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Collections.RangeSet}{GetEnumerator}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.RangeSet}{Remove}(\code{Int32} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Sets}{ScientificTools.Collections.Sets}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{ISet<T>}{}  \methoddef{ScientificTools.Collections.Sets}{Difference}(\typeref{ISet<T>}{} \code{left}, \typeref{ISet<T>}{} \code{right})
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.Collections.Sets}{Displaced}(\typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \code{set}, \code{Int32} \code{displace})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.Sets}{Equals}(\typeref{IFiniteSet<T>}{} \code{set}, \typeref{IFiniteSet<T>}{} \code{other})
        \item[] \typeref{ISet<T>}{}  \methoddef{ScientificTools.Collections.Sets}{FromMethod}(\code{Predicate<T>} \code{predicate})
        \item[] \typeref{ISet<T>}{}  \methoddef{ScientificTools.Collections.Sets}{Intersection}(\typeref{ISet<T>}{} \code{left}, \typeref{ISet<T>}{} \code{right})
        \item[] \code{String}  \methoddef{ScientificTools.Collections.Sets}{ToString}(\typeref{IFiniteSet<T>}{} \code{set})
        \item[] \typeref{ISet<T>}{}  \methoddef{ScientificTools.Collections.Sets}{Union}(\typeref{ISet<T>}{} \code{left}, \typeref{ISet<T>}{} \code{right})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Tree<T>}{ScientificTools.Collections.Tree`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{IEnumerable<T>} \propertydef{Tree`1}{Children} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Tree`1}{ChildrenCount} \code{\{ get; \}}
        \item[] \typeref{Tree<T>}{ScientificTools.Collections.Tree`1} \propertydef{Tree`1}{Item} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{Tree`1}{Value} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Collections.Tree`1}{Add}(\typeref{Tree<T>}{ScientificTools.Collections.Tree`1} \code{tree})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.Tree`1}{Remove}(\typeref{Tree<T>}{ScientificTools.Collections.Tree`1} \code{tree})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.Trees}{ScientificTools.Collections.Trees}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.Trees}{Count}(\typeref{ITree<T>}{} \code{tree})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.Trees}{Height}(\typeref{ITree<T>}{} \code{tree})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Trees}{PostOrder}(\typeref{ITree<T>}{} \code{tree})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Collections.Trees}{PreOrder}(\typeref{ITree<T>}{} \code{tree})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Collections.WeightedEdge<TNode>}{ScientificTools.Collections.WeightedEdge`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Edge<TNode>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{WeightedEdge`1}{Weight} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.WeightedEdge`1}{Equals}(\typeref{WeightedEdge<TNode>}{ScientificTools.Collections.WeightedEdge`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Collections.WeightedEdge`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Collections.WeightedEdge`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Collections.WeightedEdge`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Debug}{ScientificTools.Debug}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{Debug}{IndentLevel} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{Debug}{IndentSize} \code{\{ get; set \}}
        \item[] \code{TextWriter} \propertydef{Debug}{LogBuffer} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{Debug}{Verbosity} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Assert}(\code{Boolean} \code{condition}, \code{String} \code{format}, \code{Object[]} \code{args})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Assert}(\code{Boolean} \code{condition}, \code{String} \code{message})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{BeginTimer}()
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{BeginTimerIf}(\code{Boolean} \code{condition})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{EndTimer}()
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{EndTimerIf}(\code{Boolean} \code{condition})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Indent}()
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Post}(\code{String} \code{message})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Post}(\code{String} \code{format}, \code{Object[]} \code{args})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{PostIf}(\code{Boolean} \code{condition}, \code{String} \code{message})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{PostIf}(\code{Boolean} \code{condition}, \code{String} \code{format}, \code{Object[]} \code{args})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{ThrowOnNaN}(\code{Double} \code{value}, \code{String} \code{message})
        \item[] \code{Void}  \methoddef{ScientificTools.Debug}{Unindent}()
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.DebugLevel}{ScientificTools.DebugLevel}
        \item[Members]
        \item[] \code{Debug}
        \item[] \code{Info}
        \item[] \code{Warning}
        \item[] \code{Error}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Engine}{ScientificTools.Engine}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{Engine}{Debugging} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{Engine}{Epsilon} \code{\{ get; set \}}
        \item[] \code{Boolean} \propertydef{Engine}{OperateOnSelf} \code{\{ get; set \}}
        \item[] \code{Boolean} \propertydef{Engine}{ThrowOnNaN} \code{\{ get; set \}}
        \item[] \code{Boolean} \propertydef{Engine}{UseParallelOptimizations} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Engine}{Equals}(\code{Double} \code{d1}, \code{Double} \code{d2})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Engine}{IsZero}(\code{Double} \code{d})
        \item[] \code{Int32}  \methoddef{ScientificTools.Engine}{Sign}(\code{Double} \code{d})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.EnumerableExtensions}{ScientificTools.EnumerableExtensions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.EnumerableExtensions}{Append}(\code{IEnumerable<T>} \code{items}, \typeref{T}{} \code{last})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.EnumerableExtensions}{ArgMax}(\code{IEnumerable<T>} \code{items}, \code{Func<T,TResult>} \code{selector})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.EnumerableExtensions}{ArgMax}(\code{IEnumerable<T>} \code{items}, \code{Func<T,TResult>} \code{selector}, \code{Double} \code{value})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.EnumerableExtensions}{ArgMin}(\code{IEnumerable<T>} \code{items}, \code{Func<T,TResult>} \code{selector})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.EnumerableExtensions}{ArgMin}(\code{IEnumerable<T>} \code{items}, \code{Func<T,TResult>} \code{selector}, \code{Double} \code{value})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.EnumerableExtensions}{Batches}(\code{IEnumerable<T>} \code{items}, \code{Int32} \code{size})
        \item[] \code{Void}  \methoddef{ScientificTools.EnumerableExtensions}{Consume}(\code{IEnumerable<T>} \code{items})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.EnumerableExtensions}{Enumerate}(\code{IEnumerable<T>} \code{items})
        \item[] \code{Int32}  \methoddef{ScientificTools.EnumerableExtensions}{IndexMax}(\code{IEnumerable<T>} \code{items}, \code{Func<T,TResult>} \code{selector})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Factory<T>}{ScientificTools.Factory`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Factory`1}{Create}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.FormattingExtensions}{ScientificTools.FormattingExtensions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.FormattingExtensions}{Formatted}(\code{String} \code{format}, \code{Object[]} \code{args})
        \item[] \code{String[]}  \methoddef{ScientificTools.FormattingExtensions}{Lines}(\code{String} \code{s})
        \item[] \code{String}  \methoddef{ScientificTools.FormattingExtensions}{Ordinal}(\code{Int32} \code{index})
        \item[] \code{String[]}  \methoddef{ScientificTools.FormattingExtensions}{SplitSpaces}(\code{String} \code{s})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Functions}{ScientificTools.Functions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IFunction<T,TResult>}{}  \methoddef{ScientificTools.Functions}{FromMethod}(\code{Func<T,TResult>} \code{function})
        \item[] \code{Func<T,TResult>}  \methoddef{ScientificTools.Functions}{Max}(\code{IEnumerable<T>} \code{functions})
        \item[] \code{Func<T,TResult>}  \methoddef{ScientificTools.Functions}{Max}(\code{Func`2<T,TResult>} \code{functions})
        \item[] \code{Func<T,TResult>}  \methoddef{ScientificTools.Functions}{Sum}(\code{IEnumerable<T>} \code{functions})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Functions.MethodFunction<T,TResult>}{ScientificTools.Functions+MethodFunction`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TResult}{}  \methoddef{ScientificTools.Functions+MethodFunction`2}{Value}(\typeref{T}{} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.AlphaBetaSearch<TGame,TPlay>}{ScientificTools.GameTheory.AlphaBetaSearch`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TPlay}{}  \methoddef{ScientificTools.GameTheory.AlphaBetaSearch`2}{BestMove}(\typeref{TGame}{} \code{game}, \code{Int32} \code{player}, \code{Int32} \code{depth}, \code{CancellationToken} \code{token})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.GameTree<TGame,TPlay>}{ScientificTools.GameTheory.GameTree`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{ICollection<T>} \propertydef{GameTree`2}{AvailablePlays} \code{\{ get; \}}
        \item[] \code{ICollection<T>} \propertydef{GameTree`2}{Children} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{GameTree`2}{Count} \code{\{ get; set \}}
        \item[] \typeref{IGameKey}{ScientificTools.GameTheory.IGameKey} \propertydef{GameTree`2}{Key} \code{\{ get; \}}
        \item[] \typeref{TPlay}{} \propertydef{GameTree`2}{Play} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{GameTree`2}{Plays} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{GameTree`2}{TotalPayoff} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{GameTree`2}{Wins} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.GameTheory.GameTree`2}{Equals}(\typeref{GameTree<TGame,TPlay>}{ScientificTools.GameTheory.GameTree`2} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.GameTheory.GameTree`2}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.GameTheory.GameTree`2}{GetHashCode}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.IdAlphaBetaSearch<TGame,TPlay>}{ScientificTools.GameTheory.IdAlphaBetaSearch`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{AlphaBetaSearch<TGame,TPlay>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{IdAlphaBetaSearch`2}{Payoff} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.IdAlphaBetaSearch`2}{StartSearch}(\typeref{TGame}{} \code{game}, \code{Int32} \code{player}, \code{CancellationToken} \code{token})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.IGame<TPlay>}{ScientificTools.GameTheory.IGame`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IGame`1}{CurrentPlayer} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{IGame`1}{Finished} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{IGame`1}{Players} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IGameKey}{ScientificTools.GameTheory.IGameKey}  \methoddef{ScientificTools.GameTheory.IGame`1}{GetKey}()
        \item[] \code{Double}  \methoddef{ScientificTools.GameTheory.IGame`1}{Payoff}(\code{Int32} \code{player})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.GameTheory.IGame`1}{ValidMoves}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.IGameKey}{ScientificTools.GameTheory.IGameKey}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.IPlay}{ScientificTools.GameTheory.IPlay}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IPlay}{Player} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.IPlay}{Apply}()
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.IPlay}{Undo}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.MonteCarloSearch<TGame,TPlay>}{ScientificTools.GameTheory.MonteCarloSearch`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{GameTree<TGame,TPlay>}{} \propertydef{MonteCarloSearch`2}{Tree} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.MonteCarloSearch`2}{Expand}(\code{Int32} \code{iterations})
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.MonteCarloSearch`2}{Expand}()
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.MonteCarloSearch`2}{UpdateRoot}(\typeref{TGame}{} \code{newGame})
        \item[] \code{Void}  \methoddef{ScientificTools.GameTheory.MonteCarloSearch`2}{UpdateRoot}(\typeref{TPlay}{} \code{play})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.GameTheory.MonteCarloStrategies}{ScientificTools.GameTheory.MonteCarloStrategies}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Double}  \methoddef{ScientificTools.GameTheory.MonteCarloStrategies}{UpperConfidence}(\typeref{GameTree<TGame,TPlay>}{} \code{parent}, \typeref{GameTree<TGame,TPlay>}{} \code{child})
        \item[] \code{Double}  \methoddef{ScientificTools.GameTheory.MonteCarloStrategies}{UpperConfidence}(\typeref{GameTree<TGame,TPlay>}{} \code{parent}, \typeref{GameTree<TGame,TPlay>}{} \code{child}, \code{Double} \code{balance})
        \item[] \code{Func<T1,T2,TResult>}  \methoddef{ScientificTools.GameTheory.MonteCarloStrategies}{UpperConfidence}(\code{Double} \code{balance})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.GrahamScan}{ScientificTools.Geometry.GrahamScan}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{OfflineConvexHull2}{ScientificTools.Geometry.OfflineConvexHull2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Point2[]}{ScientificTools.Geometry.Point2[]}  \methoddef{ScientificTools.Geometry.GrahamScan}{Solve}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.JarvisMarch}{ScientificTools.Geometry.JarvisMarch}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{OfflineConvexHull2}{ScientificTools.Geometry.OfflineConvexHull2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Point2[]}{ScientificTools.Geometry.Point2[]}  \methoddef{ScientificTools.Geometry.JarvisMarch}{Solve}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.LineSweep}{ScientificTools.Geometry.LineSweep}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{OfflineClosestPair2}{ScientificTools.Geometry.OfflineClosestPair2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Pair<T>}{ScientificTools.Pair`1[[ScientificTools.Geometry.Point2, ScientificTools, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]}  \methoddef{ScientificTools.Geometry.LineSweep}{Solve}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.OfflineClosestPair2}{ScientificTools.Geometry.OfflineClosestPair2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Pair<T>}{ScientificTools.Pair`1[[ScientificTools.Geometry.Point2, ScientificTools, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]}  \methoddef{ScientificTools.Geometry.OfflineClosestPair2}{Solve}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.OfflineConvexHull2}{ScientificTools.Geometry.OfflineConvexHull2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Point2[]}{ScientificTools.Geometry.Point2[]}  \methoddef{ScientificTools.Geometry.OfflineConvexHull2}{Solve}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.Point2}{ScientificTools.Geometry.Point2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{Point2}{Angle} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Point2}{Length} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Point2}{LengthSqr} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Point2}{X} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{Point2}{Y} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{Clockwise}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{Collinear}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Point2}{CompareByPolar}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Comparison<T>}  \methoddef{ScientificTools.Geometry.Point2}{CompareByPolar}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Point2}{CompareX}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Point2}{CompareY}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{CounterClockwise}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{Equals}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Point2}{GetHashCode}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{LeftTurn}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Point2}{RightTurn}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p0}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p1}, \typeref{Point2}{ScientificTools.Geometry.Point2} \code{p2})
        \item[] \code{String}  \methoddef{ScientificTools.Geometry.Point2}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.Polygon}{ScientificTools.Geometry.Polygon}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Point2[]}{ScientificTools.Geometry.Point2[]}  \methoddef{ScientificTools.Geometry.Polygon}{RemoveCollinear}(\typeref{Point2[]}{ScientificTools.Geometry.Point2[]} \code{points})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Geometry.Segment2}{ScientificTools.Geometry.Segment2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Point2}{ScientificTools.Geometry.Point2} \propertydef{Segment2}{A} \code{\{ get; set \}}
        \item[] \typeref{Point2}{ScientificTools.Geometry.Point2} \propertydef{Segment2}{B} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Segment2}{Equals}(\typeref{Segment2}{ScientificTools.Geometry.Segment2} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Geometry.Segment2}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Segment2}{GetHashCode}()
        \item[] \code{Double}  \methoddef{ScientificTools.Geometry.Segment2}{PseudoDistance}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p})
        \item[] \code{Int32}  \methoddef{ScientificTools.Geometry.Segment2}{Side}(\typeref{Point2}{ScientificTools.Geometry.Point2} \code{p})
        \item[] \code{String}  \methoddef{ScientificTools.Geometry.Segment2}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.IAnaliticFunction}{ScientificTools.IAnaliticFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.IAnaliticFunction}{Gradient}(\typeref{Vector}{ScientificTools.Vector} \code{x})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.IAnaliticFunction}{Hessian}(\typeref{Vector}{ScientificTools.Vector} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.ICloneable<T>}{ScientificTools.ICloneable`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.ICloneable`1}{Clone}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.IContext}{ScientificTools.IContext}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{IContext}{Closed} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.IContext}{CloseContext}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.IFactory<T>}{ScientificTools.IFactory`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.IFactory`1}{Create}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.IFunction<T,TResult>}{ScientificTools.IFunction`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{TResult}{}  \methoddef{ScientificTools.IFunction`2}{Value}(\typeref{T}{} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Indexed<T>}{ScientificTools.Indexed`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{Indexed`1}{Data} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Indexed`1}{Index} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Indexed`1}{Equals}(\typeref{Indexed<T>}{ScientificTools.Indexed`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Indexed`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Indexed`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Indexed`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.IRealFunction}{ScientificTools.IRealFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IRealFunction}{Dimension} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.Automata}{ScientificTools.Language.Automata.Automata}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FDADescription}{ScientificTools.Language.Automata.FDADescription}  \methoddef{ScientificTools.Language.Automata.Automata}{ConvertToFDA}(\typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{automatonDescription})
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.Language.Automata.Automata}{EpsilonClosure}(\typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{fnda}, \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \code{states})
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.Language.Automata.Automata}{EpsilonMove}(\typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{fnda}, \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \code{states}, \code{Char} \code{c})
        \item[] \typeref{IFDATransitionFunction}{ScientificTools.Language.Automata.IFDATransitionFunction}  \methoddef{ScientificTools.Language.Automata.Automata}{FunctionFromMethod}(\code{Func<T1,T2,TResult>} \code{transitions})
        \item[] \typeref{IFNDATransitionFunction}{ScientificTools.Language.Automata.IFNDATransitionFunction}  \methoddef{ScientificTools.Language.Automata.Automata}{FunctionFromMethod}(\code{Func<T1,T2,TResult>} \code{transitions})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.Automata}{Intersect}(\typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{description1}, \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{description2})
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.Language.Automata.Automata}{Move}(\typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \code{fnda}, \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \code{states}, \code{Char} \code{c})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Automata.Automata}{Process}(\typeref{IAutomaton}{ScientificTools.Language.Automata.IAutomaton} \code{automaton}, \code{String} \code{input})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.FADescription}{ScientificTools.Language.Automata.FADescription}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \propertydef{FADescription}{FinalStates} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{FADescription}{StartingState} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{FADescription}{States} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Language.Automata.FADescription}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.FDADescription}{ScientificTools.Language.Automata.FDADescription}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{FADescription}{ScientificTools.Language.Automata.FADescription}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IFDATransitionFunction}{ScientificTools.Language.Automata.IFDATransitionFunction} \propertydef{FDADescription}{Transitions} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Language.Automata.FDADescription}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.FNDADescription}{ScientificTools.Language.Automata.FNDADescription}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{FADescription}{ScientificTools.Language.Automata.FADescription}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IFNDATransitionFunction}{ScientificTools.Language.Automata.IFNDATransitionFunction} \propertydef{FNDADescription}{Transitions} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{EndingWith}(\code{Char[]} \code{subset})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{LongerThan}(\code{Int32} \code{length})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{Recognizing}(\code{Char[]} \code{alphabet})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{ShorterThan}(\code{Int32} \code{length})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{StartingWith}(\code{Char[]} \code{subset})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{ToString}()
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{WithAtLeast}(\code{Int32} \code{count}, \code{Char} \code{c})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{WithAtMost}(\code{Int32} \code{count}, \code{Char} \code{c})
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Automata.FNDADescription}{WithExactly}(\code{Int32} \code{count}, \code{Char} \code{c})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.IAutomaton}{ScientificTools.Language.Automata.IAutomaton}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{IAutomaton}{Recognized} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Language.Automata.IAutomaton}{Feed}(\code{String} \code{input})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Automata.IAutomaton}{Step}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.IFDATransitionFunction}{ScientificTools.Language.Automata.IFDATransitionFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Automata.IFDATransitionFunction}{Evaluate}(\code{Char} \code{character}, \code{Int32} \code{state})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.IFDAutomaton}{ScientificTools.Language.Automata.IFDAutomaton}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{FDADescription}{ScientificTools.Language.Automata.FDADescription} \propertydef{IFDAutomaton}{Description} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.IFNDATransitionFunction}{ScientificTools.Language.Automata.IFNDATransitionFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IFiniteSet<T>}{ScientificTools.Collections.IFiniteSet`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.Language.Automata.IFNDATransitionFunction}{Evaluate}(\code{Char} \code{character}, \code{Int32} \code{state})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.IFNDAutomaton}{ScientificTools.Language.Automata.IFNDAutomaton}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription} \propertydef{IFNDAutomaton}{Description} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.InteractiveFDAutomaton}{ScientificTools.Language.Automata.InteractiveFDAutomaton}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{FDADescription}{ScientificTools.Language.Automata.FDADescription} \propertydef{InteractiveFDAutomaton}{Description} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{InteractiveFDAutomaton}{Recognized} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Language.Automata.InteractiveFDAutomaton}{Feed}(\code{String} \code{input})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Automata.InteractiveFDAutomaton}{Step}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.MakeAutomaton}{ScientificTools.Language.Automata.MakeAutomaton}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton}{Recognizing}(\code{Char[]} \code{alphabet})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton}{Recognizing}(\code{String} \code{chars})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton}{Recognizing}(\code{IEnumerable<T>} \code{chars})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{EndingWith}(\code{Char[]} \code{subset})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{LongerThan}(\code{Int32} \code{length})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{ShorterThan}(\code{Int32} \code{length})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{StartingWith}(\code{Char[]} \code{subset})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{WithAtLeast}(\code{Int32} \code{count}, \code{Char} \code{c})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{WithAtMost}(\code{Int32} \code{count}, \code{Char} \code{c})
        \item[] \typeref{MakeAutomaton.AutomatonBuilder}{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}  \methoddef{ScientificTools.Language.Automata.MakeAutomaton+AutomatonBuilder}{WithExactly}(\code{Int32} \code{count}, \code{Char} \code{c})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.MappedFDATranstionFunction}{ScientificTools.Language.Automata.MappedFDATranstionFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{MappedFDATranstionFunction}{Item} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Automata.MappedFDATranstionFunction}{Evaluate}(\code{Char} \code{character}, \code{Int32} \code{state})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Automata.MethodFDATranstionFunction}{ScientificTools.Language.Automata.MethodFDATranstionFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Automata.MethodFDATranstionFunction}{Evaluate}(\code{Char} \code{character}, \code{Int32} \code{state})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.BasicNode}{ScientificTools.Language.BasicNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Node}{ScientificTools.Language.Node}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.BasicNode}{Get}(\code{String} \code{property}, \typeref{T}{} \code{def})
        \item[] \code{Void}  \methoddef{ScientificTools.Language.BasicNode}{Set}(\code{String} \code{property}, \typeref{T}{} \code{value})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.BinaryAction<T1,T2>}{ScientificTools.Language.Expressions.BinaryAction`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{BinaryAction`2}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{BinaryAction`2}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{BinaryAction`2}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.BinaryFunction<T,T1,T2>}{ScientificTools.Language.Expressions.BinaryFunction`3}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{BinaryFunction`3}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{BinaryFunction`3}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{BinaryFunction`3}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.ConstantAction}{ScientificTools.Language.Expressions.ConstantAction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ConstantAction}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{ConstantAction}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{ConstantAction}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.ConstantFunction<T>}{ScientificTools.Language.Expressions.ConstantFunction`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ConstantFunction`1}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{ConstantFunction`1}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{ConstantFunction`1}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ExpressionBase}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{ExpressionBase}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{ExpressionBase}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Object}  \methoddef{ScientificTools.Language.Expressions.ExpressionBase}{Evaluate}(\code{Object[]} \code{args})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.Expressions}{ScientificTools.Language.Expressions.Expressions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.UnaryAction<T>}{ScientificTools.Language.Expressions.UnaryAction`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{UnaryAction`1}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{UnaryAction`1}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{UnaryAction`1}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Expressions.UnaryFunction<T,T1>}{ScientificTools.Language.Expressions.UnaryFunction`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ExpressionBase}{ScientificTools.Language.Expressions.ExpressionBase}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{UnaryFunction`2}{ArgsCount} \code{\{ get; \}}
        \item[] \code{Type[]} \propertydef{UnaryFunction`2}{ArgsType} \code{\{ get; \}}
        \item[] \code{Type} \propertydef{UnaryFunction`2}{ReturnType} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Language.Grammars.BottomUp.ActionCode}{ScientificTools.Language.Grammars.BottomUp.ActionCode}
        \item[Members]
        \item[] \code{Shift}
        \item[] \code{Reduce}
        \item[] \code{Accept}
        \item[] \code{Error}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable<T>}{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{ActionGotoTable`1}{Correct} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{ParsingAction<T>}{}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}{Action}(\code{Int32} \code{state}, \typeref{Token<T>}{} \code{symbol})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}{Goto}(\code{Int32} \code{state}, \typeref{Def<T>}{} \code{symbol})
        \item[] \code{Void}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}{SetAction}(\code{Int32} \code{state}, \typeref{Token<T>}{} \code{symbol}, \typeref{ParsingAction<T>}{} \code{action})
        \item[] \code{Void}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}{SetGoto}(\code{Int32} \code{state}, \typeref{Def<T>}{} \code{symbol}, \code{Int32} \code{result})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionGotoTable`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.ActionKey<T>}{ScientificTools.Language.Grammars.BottomUp.ActionKey`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ActionKey`1}{State} \code{\{ get; \}}
        \item[] \typeref{Token<T>}{} \propertydef{ActionKey`1}{Symbol} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionKey`1}{Equals}(\typeref{ActionKey<T>}{ScientificTools.Language.Grammars.BottomUp.ActionKey`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionKey`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionKey`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ActionKey`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.Goto<T>}{ScientificTools.Language.Grammars.BottomUp.Goto`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{LrState<T>}{} \propertydef{Goto`1}{Destination} \code{\{ get; set \}}
        \item[] \typeref{LrState<T>}{} \propertydef{Goto`1}{Origin} \code{\{ get; set \}}
        \item[] \typeref{Def<T>}{} \propertydef{Goto`1}{Symbol} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.GotoKey<T>}{ScientificTools.Language.Grammars.BottomUp.GotoKey`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{GotoKey`1}{State} \code{\{ get; \}}
        \item[] \typeref{Def<T>}{} \propertydef{GotoKey`1}{Symbol} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.GotoKey`1}{Equals}(\typeref{GotoKey<T>}{ScientificTools.Language.Grammars.BottomUp.GotoKey`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.GotoKey`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.GotoKey`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.GotoKey`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.IActionGotoTable<T>}{ScientificTools.Language.Grammars.BottomUp.IActionGotoTable`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{ParsingAction<T>}{}  \methoddef{ScientificTools.Language.Grammars.BottomUp.IActionGotoTable`1}{Action}(\code{Int32} \code{state}, \typeref{Token<T>}{} \code{symbol})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.IActionGotoTable`1}{Goto}(\code{Int32} \code{state}, \typeref{Def<T>}{} \code{symbol})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.LrError<T>}{ScientificTools.Language.Grammars.BottomUp.LrError`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{ParsingAction<T>}{} \propertydef{LrError`1}{Action1} \code{\{ get; \}}
        \item[] \typeref{ParsingAction<T>}{} \propertydef{LrError`1}{Action2} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{LrError`1}{State} \code{\{ get; \}}
        \item[] \typeref{Token<T>}{} \propertydef{LrError`1}{Symbol} \code{\{ get; \}}
        \item[] \typeref{LrErrorType}{ScientificTools.Language.Grammars.BottomUp.LrErrorType} \propertydef{LrError`1}{Type} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Language.Grammars.BottomUp.LrErrorType}{ScientificTools.Language.Grammars.BottomUp.LrErrorType}
        \item[Members]
        \item[] \code{ShiftReduce}
        \item[] \code{ReduceReduce}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.LrItem<T>}{ScientificTools.Language.Grammars.BottomUp.LrItem`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{ProductionRule<T>}{} \propertydef{LrItem`1}{Body} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{LrItem`1}{Count} \code{\{ get; \}}
        \item[] \code{HashSet<T>} \propertydef{LrItem`1}{Follow} \code{\{ get; set \}}
        \item[] \typeref{SlrItem<T>}{} \propertydef{LrItem`1}{Item} \code{\{ get; set \}}
        \item[] \typeref{Def<T>}{} \propertydef{LrItem`1}{NextSymbol} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{LrItem`1}{Pointer} \code{\{ get; set \}}
        \item[] \typeref{Def<T>}{} \propertydef{LrItem`1}{Symbol} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{Equals}(\typeref{LrItem<T>}{ScientificTools.Language.Grammars.BottomUp.LrItem`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{GetHashCode}()
        \item[] \typeref{LrItem<T>}{ScientificTools.Language.Grammars.BottomUp.LrItem`1}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{Next}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{ToString}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrItem`1}{TotalEquals}(\typeref{LrItem<T>}{ScientificTools.Language.Grammars.BottomUp.LrItem`1} \code{other})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.LrKernel<T>}{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}{Equals}(\typeref{LrKernel<T>}{ScientificTools.Language.Grammars.BottomUp.LrKernel`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}{Equals}(\typeref{LrItem<T>}{} \code{x}, \typeref{LrItem<T>}{} \code{y})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}{GetHashCode}()
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrKernel`1}{GetHashCode}(\typeref{LrItem<T>}{} \code{obj})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.LrParserBuilder<T>}{ScientificTools.Language.Grammars.BottomUp.LrParserBuilder`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IActionGotoTable<T>}{}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrParserBuilder`1}{Build}()
        \item[] \typeref{IActionGotoTable<T>}{}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrParserBuilder`1}{Build}(\typeref{LrState`1[<T>}{} \code{lrStates})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.LrState<T>}{ScientificTools.Language.Grammars.BottomUp.LrState`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{List<T>} \propertydef{LrState`1}{Gotos} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{LrState`1}{Index} \code{\{ get; \}}
        \item[] \typeref{LrItem<T>}{} \propertydef{LrState`1}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrState`1}{GetEnumerator}()
        \item[] \typeref{LrState<T>}{ScientificTools.Language.Grammars.BottomUp.LrState`1}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrState`1}{Goto}(\typeref{Def<T>}{} \code{symbol})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.LrState`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.ParsingAction<T>}{ScientificTools.Language.Grammars.BottomUp.ParsingAction`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{ActionCode}{ScientificTools.Language.Grammars.BottomUp.ActionCode} \propertydef{ParsingAction`1}{Code} \code{\{ get; \}}
        \item[] \typeref{Def<T>}{} \propertydef{ParsingAction`1}{LeftHand} \code{\{ get; \}}
        \item[] \typeref{ProductionRule<T>}{} \propertydef{ParsingAction`1}{RightHand} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{ParsingAction`1}{State} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ParsingAction`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.ShiftReduceParser<T>}{ScientificTools.Language.Grammars.BottomUp.ShiftReduceParser`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Grammar<T>}{} \propertydef{ShiftReduceParser`1}{Grammar} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.BottomUp.ShiftReduceParser`1}{Parse}(\typeref{TokenStream<T>}{} \code{str})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.BottomUp.SlrItem<T>}{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{ProductionRule<T>}{} \propertydef{SlrItem`1}{Body} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{SlrItem`1}{Pointer} \code{\{ get; set \}}
        \item[] \typeref{Def<T>}{} \propertydef{SlrItem`1}{Symbol} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}{Equals}(\typeref{SlrItem<T>}{ScientificTools.Language.Grammars.BottomUp.SlrItem`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}{GetHashCode}()
        \item[] \typeref{SlrItem<T>}{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}  \methoddef{ScientificTools.Language.Grammars.BottomUp.SlrItem`1}{Next}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Def<T>}{ScientificTools.Language.Grammars.Def`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Rule<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{Def`1}{IsNonTerminal} \code{\{ get; \}}
        \item[] \typeref{T}{} \propertydef{Def`1}{Node} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.Def`1}{CheckPredicates}()
        \item[] \typeref{Def<T>}{ScientificTools.Language.Grammars.Def`1}  \methoddef{ScientificTools.Language.Grammars.Def`1}{If}(\code{Func<T,TResult>} \code{rule})
        \item[] \typeref{Def<T>}{ScientificTools.Language.Grammars.Def`1}  \methoddef{ScientificTools.Language.Grammars.Def`1}{If}(\code{Func<TResult>} \code{rule})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.Def`1}{ToString}()
        \item[] \typeref{Def<T>}{ScientificTools.Language.Grammars.Def`1}  \methoddef{ScientificTools.Language.Grammars.Def`1}{With}(\code{Action<T>} \code{rule})
        \item[] \typeref{Def<T>}{ScientificTools.Language.Grammars.Def`1}  \methoddef{ScientificTools.Language.Grammars.Def`1}{With}(\code{Action<T>} \code{rule})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Generation.Generator<T>}{ScientificTools.Language.Grammars.Generation.Generator`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Language.Grammars.Generation.Generator`1}{Generate}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Generation.LSystemGenerator<T>}{ScientificTools.Language.Grammars.Generation.LSystemGenerator`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Generator<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Generation.RecursiveGenerator<T>}{ScientificTools.Language.Grammars.Generation.RecursiveGenerator`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Generator<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Selector<T>}{} \propertydef{RecursiveGenerator`1}{ProductionSelector} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Generation.Selector<T>}{ScientificTools.Language.Grammars.Generation.Selector`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Language.Grammars.Generation.Selector`1}{BeginInvoke}(\code{IEnumerable<T>} \code{set}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.Generation.Selector`1}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.Generation.Selector`1}{Invoke}(\code{IEnumerable<T>} \code{set})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Generation.Selectors}{ScientificTools.Language.Grammars.Generation.Selectors}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{ProductionRule<T>}{}  \methoddef{ScientificTools.Language.Grammars.Generation.Selectors}{Filter}(\code{IEnumerable<T>} \code{items})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.Generation.Selectors}{First}(\code{IEnumerable<T>} \code{set})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.Generation.Selectors}{Random}(\code{IEnumerable<T>} \code{set})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Grammar}{ScientificTools.Language.Grammars.Grammar}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Grammar<T>}{ScientificTools.Language.Grammars.Grammar`1[[ScientificTools.Language.BasicNode, ScientificTools, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Grammar<T>}{ScientificTools.Language.Grammars.Grammar`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{GrammarBuilder<T>}{} \propertydef{Grammar`1}{Builder} \code{\{ get; set \}}
        \item[] \typeref{Def<T>}{} \propertydef{Grammar`1}{StartSymbol} \code{\{ get; set \}}
        \item[] \code{IEnumerable<T>} \propertydef{Grammar`1}{Tokens} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Token<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Epsilon}()
        \item[] \typeref{Ref<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Ref}()
        \item[] \typeref{Def<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Rule}()
        \item[] \typeref{Def<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Rule}(\code{String} \code{name})
        \item[] \typeref{Def<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Start}(\code{String} \code{name})
        \item[] \typeref{Token<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Token}(\code{String} \code{regex})
        \item[] \typeref{Token<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Token}(\code{String} \code{name}, \code{String} \code{regex})
        \item[] \typeref{Token<T>}{}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{Token}(\code{Char} \code{c})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.Grammar`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.GrammarBuilder<T>}{ScientificTools.Language.Grammars.GrammarBuilder`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Def<T>}{} \propertydef{GrammarBuilder`1}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.GrammarItem<T>}{ScientificTools.Language.Grammars.GrammarItem`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.ParameterList<T>}{ScientificTools.Language.Grammars.ParameterList`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{ParameterList`1}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.ProductionList<T>}{ScientificTools.Language.Grammars.ProductionList`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Rule<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Language.Grammars.ProductionList`1}{GetEnumerator}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.ProductionList`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Rule<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{ProductionRule`1}{Count} \code{\{ get; \}}
        \item[] \typeref{Def<T>}{} \propertydef{ProductionRule`1}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{CheckPredicates}()
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{GetEnumerator}()
        \item[] \typeref{ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{If}(\code{Func<T,TResult>} \code{rule})
        \item[] \typeref{ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{If}(\code{Func<T,TResult>} \code{rule})
        \item[] \typeref{ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{If}(\code{Func<TResult>} \code{rule})
        \item[] \code{String}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{ToString}()
        \item[] \typeref{ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{With}(\code{Action<T>} \code{rule})
        \item[] \typeref{ProductionRule<T>}{ScientificTools.Language.Grammars.ProductionRule`1}  \methoddef{ScientificTools.Language.Grammars.ProductionRule`1}{With}(\code{Action<T>} \code{rule})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Ref<T>}{ScientificTools.Language.Grammars.Ref`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GrammarItem<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Rule<T>}{ScientificTools.Language.Grammars.Rule`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GrammarItem<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{IEnumerable<T>} \propertydef{Rule`1}{SemanticRules} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.Token<T>}{ScientificTools.Language.Grammars.Token`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Def<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{Token`1}{IsNonTerminal} \code{\{ get; \}}
        \item[] \code{String} \propertydef{Token`1}{Regex} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.TokenStream<T>}{ScientificTools.Language.Grammars.TokenStream`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Language.Grammars.TokenStream`1}{Dispose}()
        \item[] \typeref{Token<T>}{}  \methoddef{ScientificTools.Language.Grammars.TokenStream`1}{NextToken}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Grammars.TopDown.PredictiveParser<T>}{ScientificTools.Language.Grammars.TopDown.PredictiveParser`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Grammar<T>}{} \propertydef{PredictiveParser`1}{Grammar} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Grammars.TopDown.PredictiveParser`1}{Parse}(\typeref{TokenStream<T>}{} \code{str})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.ILexer<T>}{ScientificTools.Language.ILexer`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.ILexer`1}{NextToken}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.IParser<T>}{ScientificTools.Language.IParser`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Grammar<T>}{} \propertydef{IParser`1}{Grammar} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.IParser`1}{Parse}(\typeref{TokenStream<T>}{} \code{str})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Node}{ScientificTools.Language.Node}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{String} \propertydef{Node}{Column} \code{\{ get; set \}}
        \item[] \code{Boolean} \propertydef{Node}{Eof} \code{\{ get; set \}}
        \item[] \code{Boolean} \propertydef{Node}{Error} \code{\{ get; set \}}
        \item[] \code{String} \propertydef{Node}{Line} \code{\{ get; set \}}
        \item[] \code{String} \propertydef{Node}{Match} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.NotMatchedException}{ScientificTools.Language.NotMatchedException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ParsingException}{ScientificTools.Language.ParsingException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{String} \propertydef{NotMatchedException}{Expression} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Language.NotMatchedException}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Parsers}{ScientificTools.Language.Parsers}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IParser<T>}{}  \methoddef{ScientificTools.Language.Parsers}{BuildLl}(\typeref{Grammar<T>}{} \code{grammar})
        \item[] \typeref{IParser<T>}{}  \methoddef{ScientificTools.Language.Parsers}{BuildLr}(\typeref{Grammar<T>}{} \code{grammar})
        \item[] \typeref{IParser<T>}{}  \methoddef{ScientificTools.Language.Parsers}{BuildLr}(\typeref{Grammar<T>}{} \code{grammar}, \typeref{LrState`1[<T>}{} \code{states})
        \item[] \typeref{IParser<T>}{}  \methoddef{ScientificTools.Language.Parsers}{Load}(\code{Stream} \code{stream})
        \item[] \typeref{IParser<T>}{}  \methoddef{ScientificTools.Language.Parsers}{Load}(\code{String} \code{path})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Parsers}{Parse}(\typeref{IParser<T>}{} \code{parser}, \code{String} \code{path})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Parsers}{Parse}(\typeref{IParser<T>}{} \code{parser}, \code{Stream} \code{stream})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Language.Parsers}{ParseString}(\typeref{IParser<T>}{} \code{parser}, \code{String} \code{str})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.ParsingException}{ScientificTools.Language.ParsingException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{Exception}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.IRegexNode}{ScientificTools.Language.Regex.IRegexNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{IRegexNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.IRegexNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.IRegexNode}{Simplify}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexBinaryNode}{ScientificTools.Language.Regex.RegexBinaryNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode} \propertydef{RegexBinaryNode}{Left} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{RegexBinaryNode}{Priority} \code{\{ get; \}}
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode} \propertydef{RegexBinaryNode}{Right} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexBinaryNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexBinaryNode}{Simplify}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexClosureNode}{ScientificTools.Language.Regex.RegexClosureNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{RegexUnaryNode}{ScientificTools.Language.Regex.RegexUnaryNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RegexClosureNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexClosureNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexClosureNode}{Simplify}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Regex.RegexClosureNode}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexConcatNode}{ScientificTools.Language.Regex.RegexConcatNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{RegexBinaryNode}{ScientificTools.Language.Regex.RegexBinaryNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RegexConcatNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexConcatNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexConcatNode}{Simplify}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Regex.RegexConcatNode}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexLeafNode}{ScientificTools.Language.Regex.RegexLeafNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RegexLeafNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexLeafNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexLeafNode}{Simplify}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexLexer}{ScientificTools.Language.Regex.RegexLexer}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{RegexToken}{ScientificTools.Language.Regex.RegexToken}  \methoddef{ScientificTools.Language.Regex.RegexLexer}{NextToken}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexLiteralNode}{ScientificTools.Language.Regex.RegexLiteralNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{RegexLeafNode}{ScientificTools.Language.Regex.RegexLeafNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{String} \propertydef{RegexLiteralNode}{Literal} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{RegexLiteralNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexLiteralNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexLiteralNode}{Simplify}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Regex.RegexLiteralNode}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexParser}{ScientificTools.Language.Regex.RegexParser}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexParser}{Parse}(\code{String} \code{input})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexToken}{ScientificTools.Language.Regex.RegexToken}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{RegexTokenType}{ScientificTools.Language.Regex.RegexTokenType} \propertydef{RegexToken}{Type} \code{\{ get; set \}}
        \item[] \code{Char} \propertydef{RegexToken}{Value} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Regex.RegexToken}{Equals}(\typeref{RegexToken}{ScientificTools.Language.Regex.RegexToken} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Language.Regex.RegexToken}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Language.Regex.RegexToken}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Regex.RegexToken}{ToString}()
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Language.Regex.RegexTokenType}{ScientificTools.Language.Regex.RegexTokenType}
        \item[Members]
        \item[] \code{Literal}
        \item[] \code{OpenBracket}
        \item[] \code{CloseBracket}
        \item[] \code{Clousure}
        \item[] \code{Union}
        \item[] \code{End}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexUnaryNode}{ScientificTools.Language.Regex.RegexUnaryNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode} \propertydef{RegexUnaryNode}{InternalNode} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{RegexUnaryNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexUnaryNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexUnaryNode}{Simplify}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.Regex.RegexUnionNode}{ScientificTools.Language.Regex.RegexUnionNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{RegexBinaryNode}{ScientificTools.Language.Regex.RegexBinaryNode}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{RegexUnionNode}{Priority} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{FNDADescription}{ScientificTools.Language.Automata.FNDADescription}  \methoddef{ScientificTools.Language.Regex.RegexUnionNode}{Compile}()
        \item[] \typeref{IRegexNode}{ScientificTools.Language.Regex.IRegexNode}  \methoddef{ScientificTools.Language.Regex.RegexUnionNode}{Simplify}()
        \item[] \code{String}  \methoddef{ScientificTools.Language.Regex.RegexUnionNode}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.UnexpectedTokenException}{ScientificTools.Language.UnexpectedTokenException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ParsingException}{ScientificTools.Language.ParsingException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Language.WrongTokenException<T>}{ScientificTools.Language.WrongTokenException`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ParsingException}{ScientificTools.Language.ParsingException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{WrongTokenException`1}{CurrentToken} \code{\{ get; set \}}
        \item[] \typeref{T[]}{} \propertydef{WrongTokenException`1}{ExpectedTokens} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Language.WrongTokenException`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Logger}{ScientificTools.Logger}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{TextWriter} \propertydef{Logger}{Writer} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Logger}{Log}(\code{String} \code{message}, \code{Object[]} \code{args})
        \item[] \typeref{IContext}{ScientificTools.IContext}  \methoddef{ScientificTools.Logger}{OpenContext}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Matrices}{ScientificTools.Matrices}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Basis}(\code{Int32} \code{dimension}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{basis})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Basis}(\code{IEnumerable<T>} \code{basis})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Identity}(\code{Int32} \code{order})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Ones}(\code{Int32} \code{rows}, \code{Int32} \code{columns})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Random}(\code{Int32} \code{rows}, \code{Int32} \code{columns})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Random}(\code{Int32} \code{rows}, \code{Int32} \code{columns}, \code{Int32} \code{digits})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Random}(\code{Int32} \code{rows}, \code{Int32} \code{columns}, \typeref{RandomEx}{ScientificTools.Probabilities.RandomEx} \code{random})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Random}(\code{Int32} \code{rows}, \code{Int32} \code{columns}, \code{Int32} \code{digits}, \typeref{RandomEx}{ScientificTools.Probabilities.RandomEx} \code{random})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrices}{Zeros}(\code{Int32} \code{rows}, \code{Int32} \code{columns})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Matrix}{ScientificTools.Matrix}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{Matrix}{Columns} \code{\{ get; \}}
        \item[] \code{Double[,]} \propertydef{Matrix}{Elements} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Matrix}{Item} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{Matrix}{Item} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{Matrix}{Item} \code{\{ get; set \}}
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{Matrix}{Item} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{Matrix}{Rows} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{Matrix}{Squared} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Add}(\typeref{Matrix}{ScientificTools.Matrix} \code{other})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Add}(\typeref{Matrix}{ScientificTools.Matrix} \code{left}, \typeref{Matrix}{ScientificTools.Matrix} \code{right})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Clone}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Matrix}{Column}(\code{Int32} \code{column})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{ColumnPermutations}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{ComponentDivide}(\typeref{Matrix}{ScientificTools.Matrix} \code{other})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{ComponentMultiply}(\typeref{Matrix}{ScientificTools.Matrix} \code{other})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Diagonal}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Divide}(\code{Double} \code{scalar})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Divide}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Double} \code{scalar})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Matrix}{Equals}(\typeref{Matrix}{ScientificTools.Matrix} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Matrix}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Matrix}{GetHashCode}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{LowerDiagonal}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Multiply}(\code{Double} \code{scalar})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Multiply}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Double} \code{scalar})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Multiply}(\typeref{Matrix}{ScientificTools.Matrix} \code{left}, \typeref{Matrix}{ScientificTools.Matrix} \code{right})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Matrix}{Row}(\code{Int32} \code{row})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{RowPermutations}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Subtract}(\typeref{Matrix}{ScientificTools.Matrix} \code{other})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Subtract}(\typeref{Matrix}{ScientificTools.Matrix} \code{left}, \typeref{Matrix}{ScientificTools.Matrix} \code{right})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{SwapColumns}(\code{Int32} \code{i}, \code{Int32} \code{j})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{SwapRows}(\code{Int32} \code{i}, \code{Int32} \code{j})
        \item[] \code{String}  \methoddef{ScientificTools.Matrix}{ToString}(\code{Int32} \code{digits})
        \item[] \code{String}  \methoddef{ScientificTools.Matrix}{ToString}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Transpose}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{Transpose}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix}{UpperDiagonal}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Matrix.Builder}{ScientificTools.Matrix+Builder}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Matrix+Builder}{Build}()
        \item[] \code{String}  \methoddef{ScientificTools.Matrix+Builder}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Matrix.ComponentWiseOperator}{ScientificTools.Matrix+ComponentWiseOperator}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.MethodComparer<T>}{ScientificTools.MethodComparer`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.MethodComparer`1}{Compare}(\typeref{T}{} \code{x}, \typeref{T}{} \code{y})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.NowWhatException}{ScientificTools.NowWhatException}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{Exception}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.NumberTheory.ModularMath}{ScientificTools.NumberTheory.ModularMath}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int64}  \methoddef{ScientificTools.NumberTheory.ModularMath}{Multiply}(\code{Int64} \code{a}, \code{Int64} \code{b}, \code{Int64} \code{mod})
        \item[] \code{Int64}  \methoddef{ScientificTools.NumberTheory.ModularMath}{Pow}(\code{Int64} \code{x}, \code{Int64} \code{n}, \code{Int64} \code{mod})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.NumberTheory.PascalTriangle}{ScientificTools.NumberTheory.PascalTriangle}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{PascalTriangle}{Item} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.NumberTheory.Primes}{ScientificTools.NumberTheory.Primes}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]} \propertydef{Primes}{List} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.NumberTheory.Primes}{Check}(\code{Int32} \code{n})
        \item[] \code{Boolean}  \methoddef{ScientificTools.NumberTheory.Primes}{RabinMiller}(\code{Int64} \code{p}, \code{IEnumerable<T>} \code{candidates})
        \item[] \typeref{ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.NumberTheory.Primes}{Range}(\code{Int32} \code{length})
        \item[] \typeref{ArraySlice<T>}{ScientificTools.Collections.ArraySlice`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}  \methoddef{ScientificTools.NumberTheory.Primes}{Range}(\code{Int32} \code{start}, \code{Int32} \code{length})
        \item[] \code{Boolean[]}  \methoddef{ScientificTools.NumberTheory.Primes}{Sieve}(\code{Int32} \code{length})
        \item[] \code{Boolean[]}  \methoddef{ScientificTools.NumberTheory.Primes}{Sieve}(\code{Int32} \code{length}, \code{Int32} \code{count})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.DifferentialFunction}{BeginInvoke}(\code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.DifferentialFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.DifferentialFunction}{Invoke}(\code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.DifferentialFunctions}{ScientificTools.Numerics.DifferentialFunctions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}  \methoddef{ScientificTools.Numerics.DifferentialFunctions}{Solve}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{method})
        \item[] \typeref{DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}  \methoddef{ScientificTools.Numerics.DifferentialFunctions}{Solve}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{starter}, \typeref{MultiStepMethod}{ScientificTools.Numerics.MultiStepMethod} \code{method}, \code{Int32} \code{iterations})
        \item[] \typeref{DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}  \methoddef{ScientificTools.Numerics.DifferentialFunctions}{Solve}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{predictor}, \typeref{SingleStepCorrector}{ScientificTools.Numerics.SingleStepCorrector} \code{corrector}, \code{Int32} \code{iterations})
        \item[] \typeref{DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}  \methoddef{ScientificTools.Numerics.DifferentialFunctions}{Solve}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{starter}, \typeref{MultiStepMethod}{ScientificTools.Numerics.MultiStepMethod} \code{predictor}, \typeref{MultiStepMethod}{ScientificTools.Numerics.MultiStepMethod} \code{corrector}, \code{Int32} \code{starterIterations}, \code{Int32} \code{iterations})
        \item[] \typeref{DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}  \methoddef{ScientificTools.Numerics.DifferentialFunctions}{Solve}(\typeref{Integrator}{ScientificTools.Numerics.Integrator} \code{integrator}, \typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.DifferentialSolution}{ScientificTools.Numerics.DifferentialSolution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Numerics.DifferentialSolution}{GetEnumerator}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.DifferentialSolution}{Iterate}(\code{Int32} \code{iterations})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.Factorization}{ScientificTools.Numerics.Factorization}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{Factorization}{Matrix} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{Factorization}{Singular} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Factorization}{SingularColumn} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.Integrator}{ScientificTools.Numerics.Integrator}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.Integrator}{BeginInvoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.Integrator}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.Integrator}{Invoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.Integrators}{ScientificTools.Numerics.Integrators}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Integrator}{ScientificTools.Numerics.Integrator}  \methoddef{ScientificTools.Numerics.Integrators}{MultiStep}(\typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{starter}, \typeref{MultiStepMethod}{ScientificTools.Numerics.MultiStepMethod} \code{method}, \code{Int32} \code{iterations})
        \item[] \typeref{Integrator}{ScientificTools.Numerics.Integrator}  \methoddef{ScientificTools.Numerics.Integrators}{PredictorCorrector}(\typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{predictor}, \typeref{SingleStepCorrector}{ScientificTools.Numerics.SingleStepCorrector} \code{corrector}, \code{Int32} \code{iterations})
        \item[] \typeref{Integrator}{ScientificTools.Numerics.Integrator}  \methoddef{ScientificTools.Numerics.Integrators}{SingleStep}(\typeref{SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod} \code{method})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LdlFactorization}{ScientificTools.Numerics.LdlFactorization}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Factorization}{ScientificTools.Numerics.Factorization}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{LdlFactorization}{Diagonal} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{LdlFactorization}{Eigenvalues} \code{\{ get; \}}
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{LdlFactorization}{Lower} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LdlSolution}{ScientificTools.Numerics.LdlSolution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{LinearSolution}{ScientificTools.Numerics.LinearSolution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{LdlSolution}{Diagonal} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{LdlSolution}{Eigenvalues} \code{\{ get; \}}
        \item[] \typeref{Matrix}{ScientificTools.Matrix} \propertydef{LdlSolution}{Lower} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LeastSquaresFitting<T>}{ScientificTools.Numerics.LeastSquaresFitting`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Numerics.LeastSquaresFitting`1}{Add}(\typeref{T}{} \code{x}, \code{Double} \code{y})
        \item[] \typeref{LinearCombinationFunction<T>}{}  \methoddef{ScientificTools.Numerics.LeastSquaresFitting`1}{Fit}(\code{Double} \code{error}, \typeref{IFunction`2<T,Double>}{} \code{bases})
        \item[] \typeref{LinearCombinationFunction<T>}{}  \methoddef{ScientificTools.Numerics.LeastSquaresFitting`1}{Fit}(\typeref{IFunction`2<T,Double>}{} \code{bases})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LinearCombinationFunction<T>}{ScientificTools.Numerics.LinearCombinationFunction`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{LinearCombinationFunction`1}{Coeficients} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Double}  \methoddef{ScientificTools.Numerics.LinearCombinationFunction`1}{Value}(\typeref{T}{} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LinearSolution}{ScientificTools.Numerics.LinearSolution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{LinearSolution}{SingularColumn} \code{\{ get; \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{LinearSolution}{Solution} \code{\{ get; \}}
        \item[] \typeref{LinearSolutionType}{ScientificTools.Numerics.LinearSolutionType} \propertydef{LinearSolution}{Type} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Numerics.LinearSolutionType}{ScientificTools.Numerics.LinearSolutionType}
        \item[Members]
        \item[] \code{Definite}
        \item[] \code{Infinite}
        \item[] \code{Singular}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LinearSolver}{ScientificTools.Numerics.LinearSolver}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.LinearSolver}{BeginInvoke}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{LinearSolution}{ScientificTools.Numerics.LinearSolution}  \methoddef{ScientificTools.Numerics.LinearSolver}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{LinearSolution}{ScientificTools.Numerics.LinearSolution}  \methoddef{ScientificTools.Numerics.LinearSolver}{Invoke}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.LinearSystems}{ScientificTools.Numerics.LinearSystems}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.LinearSystems}{BackSubstitution}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.LinearSystems}{FowardSubstitution}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector})
        \item[] \typeref{LdlFactorization}{ScientificTools.Numerics.LdlFactorization}  \methoddef{ScientificTools.Numerics.LinearSystems}{LdlFactorization}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix})
        \item[] \typeref{LdlSolution}{ScientificTools.Numerics.LdlSolution}  \methoddef{ScientificTools.Numerics.LinearSystems}{LdlSolve}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector})
        \item[] \typeref{Factorization}{ScientificTools.Numerics.Factorization}  \methoddef{ScientificTools.Numerics.LinearSystems}{PluFactorization}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{PivotStrategy}{ScientificTools.Numerics.PivotStrategy} \code{pivotStrategy})
        \item[] \typeref{LinearSolution}{ScientificTools.Numerics.LinearSolution}  \methoddef{ScientificTools.Numerics.LinearSystems}{PluSolve}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \typeref{PivotStrategy}{ScientificTools.Numerics.PivotStrategy} \code{pivotStrategy})
        \item[] \typeref{PivotStrategy}{ScientificTools.Numerics.PivotStrategy}  \methoddef{ScientificTools.Numerics.LinearSystems}{ScaledPivot}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix})
        \item[] \code{Int32}  \methoddef{ScientificTools.Numerics.LinearSystems}{SimplePivot}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Int32} \code{index}, \code{Int32} \code{dimension})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Numerics.LinearSystems}{TryLdlFactorization}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Int32} \code{singularColumn})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Numerics.LinearSystems}{TryLdlSolve}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \typeref{Vector}{ScientificTools.Vector&} \code{result}, \code{Int32} \code{singularColumn})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Numerics.LinearSystems}{TryPluFactorization}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{PivotStrategy}{ScientificTools.Numerics.PivotStrategy} \code{pivotStrategy}, \code{Int32} \code{singularColumn})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Numerics.LinearSystems}{TryPluSolve}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector}, \typeref{PivotStrategy}{ScientificTools.Numerics.PivotStrategy} \code{pivotStrategy}, \typeref{Vector}{ScientificTools.Vector&} \code{result}, \code{Int32} \code{singularColumn})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.MultiStepCorrector}{ScientificTools.Numerics.MultiStepCorrector}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.MultiStepCorrector}{BeginInvoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepCorrector}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepCorrector}{Invoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.MultiStepCorrectors}{ScientificTools.Numerics.MultiStepCorrectors}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepCorrectors}{AdamsMoulton}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.MultiStepMethod}{ScientificTools.Numerics.MultiStepMethod}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.MultiStepMethod}{BeginInvoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \code{Double} \code{step}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepMethod}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepMethod}{Invoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.MultiStepMethods}{ScientificTools.Numerics.MultiStepMethods}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepMethods}{AdamBashforth}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \code{Double} \code{step})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepMethods}{Method1}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \code{Double} \code{step})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.MultiStepMethods}{Milne}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.PivotStrategy}{ScientificTools.Numerics.PivotStrategy}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.PivotStrategy}{BeginInvoke}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Int32} \code{index}, \code{Int32} \code{dimension}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Int32}  \methoddef{ScientificTools.Numerics.PivotStrategy}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Int32}  \methoddef{ScientificTools.Numerics.PivotStrategy}{Invoke}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \code{Int32} \code{index}, \code{Int32} \code{dimension})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.SingleStepCorrector}{ScientificTools.Numerics.SingleStepCorrector}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.SingleStepCorrector}{BeginInvoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepCorrector}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepCorrector}{Invoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.SingleStepCorrectors}{ScientificTools.Numerics.SingleStepCorrectors}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepCorrectors}{Method}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \typeref{Vector}{ScientificTools.Vector} \code{yIter}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.SingleStepMethod}{ScientificTools.Numerics.SingleStepMethod}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Numerics.SingleStepMethod}{BeginInvoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepMethod}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepMethod}{Invoke}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Numerics.SingleStepMethods}{ScientificTools.Numerics.SingleStepMethods}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepMethods}{Euler}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepMethods}{RungeKutta2}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Numerics.SingleStepMethods}{RungeKutta4}(\typeref{DifferentialFunction}{ScientificTools.Numerics.DifferentialFunction} \code{function}, \code{Double} \code{x}, \typeref{Vector}{ScientificTools.Vector} \code{y}, \code{Double} \code{step})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.BreedingFunction}{ScientificTools.Optimization.Aproximate.BreedingFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.BreedingFunction}{BeginInvoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{parents}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.BreedingFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.BreedingFunction}{Invoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{parents})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.DifferentialEvolution}{ScientificTools.Optimization.Aproximate.DifferentialEvolution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{OptimizerResult}{ScientificTools.Optimization.OptimizerResult}  \methoddef{ScientificTools.Optimization.Aproximate.DifferentialEvolution}{Run}(\typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.GenerationFunction}{ScientificTools.Optimization.Aproximate.GenerationFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.GenerationFunction}{BeginInvoke}(\code{Int32} \code{size}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.GenerationFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.GenerationFunction}{Invoke}(\code{Int32} \code{size})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.HillClimbing}{ScientificTools.Optimization.Aproximate.HillClimbing}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{HillClimbing}{Iterations} \code{\{ get; \}}
        \item[] \typeref{NeighborhoodFunction}{ScientificTools.Optimization.Aproximate.NeighborhoodFunction} \propertydef{HillClimbing}{NeighborhoodFunction} \code{\{ get; \}}
        \item[] \typeref{LocalSelector}{ScientificTools.Optimization.Aproximate.LocalSelector} \propertydef{HillClimbing}{Selector} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{OptimizerResult}{ScientificTools.Optimization.OptimizerResult}  \methoddef{ScientificTools.Optimization.Aproximate.HillClimbing}{Run}(\typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.LocalSelector}{ScientificTools.Optimization.Aproximate.LocalSelector}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.LocalSelector}{BeginInvoke}(\typeref{Vector}{ScientificTools.Vector} \code{current}, \typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \code{IEnumerable<T>} \code{neighboors}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Optimization.Aproximate.LocalSelector}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Optimization.Aproximate.LocalSelector}{Invoke}(\typeref{Vector}{ScientificTools.Vector} \code{current}, \typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \code{IEnumerable<T>} \code{neighboors})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.NeighborhoodFunction}{ScientificTools.Optimization.Aproximate.NeighborhoodFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.NeighborhoodFunction}{BeginInvoke}(\typeref{Vector}{ScientificTools.Vector} \code{point}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Optimization.Aproximate.NeighborhoodFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Optimization.Aproximate.NeighborhoodFunction}{Invoke}(\typeref{Vector}{ScientificTools.Vector} \code{point})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.Population}{ScientificTools.Optimization.Aproximate.Population}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Optimization.Aproximate.Population}{Breed}(\typeref{BreedingFunction}{ScientificTools.Optimization.Aproximate.BreedingFunction} \code{breeding}, \typeref{SelectionFunction}{ScientificTools.Optimization.Aproximate.SelectionFunction} \code{selection})
        \item[] \code{Void}  \methoddef{ScientificTools.Optimization.Aproximate.Population}{Evaluate}(\typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function})
        \item[] \code{Void}  \methoddef{ScientificTools.Optimization.Aproximate.Population}{Generate}(\typeref{GenerationFunction}{ScientificTools.Optimization.Aproximate.GenerationFunction} \code{generation})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.Select}{ScientificTools.Optimization.Aproximate.Select}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Optimization.Aproximate.Select}{Best}(\typeref{Vector}{ScientificTools.Vector} \code{current}, \typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \code{IEnumerable<T>} \code{neighboors})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Optimization.Aproximate.Select}{FirstBetter}(\typeref{Vector}{ScientificTools.Vector} \code{current}, \typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \code{IEnumerable<T>} \code{neighboors})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.SelectionFunction}{ScientificTools.Optimization.Aproximate.SelectionFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.SelectionFunction}{BeginInvoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{parents}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{children}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.SelectionFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \typeref{Vector[]}{ScientificTools.Vector[]}  \methoddef{ScientificTools.Optimization.Aproximate.SelectionFunction}{Invoke}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{parents}, \typeref{Vector[]}{ScientificTools.Vector[]} \code{children})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.SimulatedAnnealing}{ScientificTools.Optimization.Aproximate.SimulatedAnnealing}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{NeighborhoodFunction}{ScientificTools.Optimization.Aproximate.NeighborhoodFunction} \propertydef{SimulatedAnnealing}{NeighborhoodFunction} \code{\{ get; \}}
        \item[] \typeref{TemperatureFunction}{ScientificTools.Optimization.Aproximate.TemperatureFunction} \propertydef{SimulatedAnnealing}{TemperatureFunction} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{OptimizerResult}{ScientificTools.Optimization.OptimizerResult}  \methoddef{ScientificTools.Optimization.Aproximate.SimulatedAnnealing}{Run}(\typeref{IRealFunction}{ScientificTools.IRealFunction} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Aproximate.TemperatureFunction}{ScientificTools.Optimization.Aproximate.TemperatureFunction}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Optimization.Aproximate.TemperatureFunction}{BeginInvoke}(\code{Int32} \code{iteration}, \code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Double}  \methoddef{ScientificTools.Optimization.Aproximate.TemperatureFunction}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Double}  \methoddef{ScientificTools.Optimization.Aproximate.TemperatureFunction}{Invoke}(\code{Int32} \code{iteration})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Exact.HomotopyEventArgs}{ScientificTools.Optimization.Exact.HomotopyEventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{EventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{IRealFunction}{ScientificTools.IRealFunction} \propertydef{HomotopyEventArgs}{Function} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{HomotopyEventArgs}{Gradient} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{HomotopyEventArgs}{Iteration} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{HomotopyEventArgs}{Parameter} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{HomotopyEventArgs}{Point} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.Exact.HomotopyOptimizer}{ScientificTools.Optimization.Exact.HomotopyOptimizer}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{HomotopyOptimizer}{MaxIterations} \code{\{ get; set \}}
        \item[] \code{Int32} \propertydef{HomotopyOptimizer}{MaxPaths} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{HomotopyOptimizer}{MaxValue} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{HomotopyOptimizer}{MinValue} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{OptimizerResult}{ScientificTools.Optimization.OptimizerResult}  \methoddef{ScientificTools.Optimization.Exact.HomotopyOptimizer}{Run}(\typeref{IAnaliticFunction}{ScientificTools.IAnaliticFunction} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
        \item[] \code{String}  \methoddef{ScientificTools.Optimization.Exact.HomotopyOptimizer}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.IExactOptimizer}{ScientificTools.Optimization.IExactOptimizer}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.IOptimizer}{ScientificTools.Optimization.IOptimizer}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.IOptimizer<TFunction,T,TResult>}{ScientificTools.Optimization.IOptimizer`3}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{OptimizerResult}{ScientificTools.Optimization.OptimizerResult}  \methoddef{ScientificTools.Optimization.IOptimizer`3}{Run}(\typeref{TFunction}{} \code{function}, \typeref{Vector}{ScientificTools.Vector} \code{startingPoint})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Optimization.OptimizerResult}{ScientificTools.Optimization.OptimizerResult}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{OptimizerResult}{Minimun} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{OptimizerResult}{Success} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{OptimizerResult}{Value} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Optimization.OptimizerResult}{ToString}()
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Optimization.OptimizerStatus}{ScientificTools.Optimization.OptimizerStatus}
        \item[Members]
        \item[] \code{Success}
        \item[] \code{MaxIterationsReached}
        \item[] \code{NonConvergenceDetected}
        \item[] \code{InternalInvariantError}
        \item[] \code{GeneralFailure}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pair<T>}{ScientificTools.Pair`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{ValueType}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{Pair`1}{A} \code{\{ get; set \}}
        \item[] \typeref{T}{} \propertydef{Pair`1}{B} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pair`1}{Equals}(\typeref{Pair<T>}{ScientificTools.Pair`1} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pair`1}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Pair`1}{GetHashCode}()
        \item[] \code{String}  \methoddef{ScientificTools.Pair`1}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.AStarWalker<TNode,TEdge>}{ScientificTools.Pathfinding.AStarWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{BestFirstWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.BestFirstWalker<TNode,TEdge>}{ScientificTools.Pathfinding.BestFirstWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GraphWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.BestFirstWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.BidirectionalGraphWalker<TNode,TEdge>}{ScientificTools.Pathfinding.BidirectionalGraphWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{BidirectionalGraphWalker`2}{Found} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{BidirectionalGraphWalker`2}{Hits} \code{\{ get; \}}
        \item[] \code{IEnumerable<T>} \propertydef{BidirectionalGraphWalker`2}{Path} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.BidirectionalGraphWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{end})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.BreadthFirstWalker<TNode,TEdge>}{ScientificTools.Pathfinding.BreadthFirstWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GraphWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.BreadthFirstWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.DepthFirstWalker<TNode,TEdge>}{ScientificTools.Pathfinding.DepthFirstWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GraphWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.DepthFirstWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.GraphWalker<TNode,TEdge>}{ScientificTools.Pathfinding.GraphWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{IDictionary<TKey,TValue>} \propertydef{GraphWalker`2}{Crossings} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{GraphWalker`2}{Hits} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.GraphWalker`2}{Visited}(\typeref{TNode}{} \code{node})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.GraphWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.GreedyWalker<TNode,TEdge>}{ScientificTools.Pathfinding.GreedyWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{BestFirstWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.IGraphWalker<TNode,TEdge>}{ScientificTools.Pathfinding.IGraphWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.IGraphWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.RandomizedGreedyWalker<TNode,TEdge>}{ScientificTools.Pathfinding.RandomizedGreedyWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{GraphWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.RandomizedGreedyWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.Search}{ScientificTools.Pathfinding.Search}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{AStar}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{goal}, \code{Func<T,TResult>} \code{heuristic})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{AStar}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal}, \code{Func<T,TResult>} \code{heuristic})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{AStar}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal}, \code{Func<T,TResult>} \code{heuristic}, \code{Boolean} \code{found}, \typeref{TNode}{} \code{end})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Bfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{goal})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Bfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Bfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal}, \code{Boolean} \code{found}, \typeref{TNode}{} \code{end})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.Search}{Cost}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Dfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{goal})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Dfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{Dfs}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal}, \code{Boolean} \code{found}, \typeref{TNode}{} \code{end})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.Search}{Distance}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Search}{SMAStar}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{goal}, \code{Func<T,TResult>} \code{heuristic}, \code{Int32} \code{size}, \code{CancellationTokenSource} \code{cancel}, \code{Boolean} \code{optimal})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.SmaStarWalker<TNode,TEdge>}{ScientificTools.Pathfinding.SmaStarWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2}{Walk}(\typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{root}, \typeref{TNode}{} \code{end})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.SmaStarWalker<TNode,TEdge>.Fringe}{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{SmaStarWalker<TNode,TEdge>.Node}{} \propertydef{Fringe}{Best} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Fringe}{Count} \code{\{ get; \}}
        \item[] \code{ICollection<T>} \propertydef{Fringe}{Leaves} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Fringe}{Size} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{Check}()
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{Close}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{Contains}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{IsClosed}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{IsOpen}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{Open}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{RemoveOpen}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
        \item[] \typeref{SmaStarWalker<TNode,TEdge>.Node}{}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{RemoveWorst}()
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{ReOpen}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{parent})
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Fringe}{UpdateLeafStatus}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{} \code{node})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{Node}{AllInMemory} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{Node}{Completed} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{Node}{IsLeaf} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{Node}{IsRoot} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Node}{SuccesorsForgotten} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Node}{SuccesorsInMemory} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{Node}{SuccesorsSkipped} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Equals}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Equals}(\code{Object} \code{obj})
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Forget}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node} \code{node})
        \item[] \code{Int32}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{GetHashCode}()
        \item[] \typeref{SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Next}()
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Own}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node} \code{node})
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{Skip}(\typeref{SmaStarWalker<TNode,TEdge>.Node}{ScientificTools.Pathfinding.SmaStarWalker`2+Node} \code{node})
        \item[] \code{String}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{ToString}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.SmaStarWalker`2+Node}{UpdateFCost}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.UniformCostWalker<TNode,TEdge>}{ScientificTools.Pathfinding.UniformCostWalker`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{AStarWalker<TNode,TEdge>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.Walk<TNode,TEdge>}{ScientificTools.Pathfinding.Walk`2}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{Walk`2}{Count} \code{\{ get; \}}
        \item[] \typeref{TEdge}{} \propertydef{Walk`2}{Item} \code{\{ get; \}}
        \item[] \code{IEnumerable<T>} \propertydef{Walk`2}{Nodes} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Pathfinding.Walk`2}{Augment}(\typeref{Walk<TNode,TEdge>}{ScientificTools.Pathfinding.Walk`2} \code{rest})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Pathfinding.Walk`2}{Contains}(\typeref{TNode}{} \code{node})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.Walk`2}{Edges}(\typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{end})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Pathfinding.Walk`2}{Path}(\typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{end})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Pathfinding.Walkers}{ScientificTools.Pathfinding.Walkers}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Walkers}{Walk}(\typeref{IGraphWalker<TNode,TEdge>}{} \code{walker}, \typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Walkers}{Walk}(\typeref{IGraphWalker<TNode,TEdge>}{} \code{walker}, \typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \typeref{TNode}{} \code{end})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Walkers}{Walk}(\typeref{IGraphWalker<TNode,TEdge>}{} \code{walker}, \typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal})
        \item[] \typeref{Walk<TNode,TEdge>}{}  \methoddef{ScientificTools.Pathfinding.Walkers}{Walk}(\typeref{IGraphWalker<TNode,TEdge>}{} \code{walker}, \typeref{IGraph<TNode,TEdge>}{} \code{graph}, \typeref{TNode}{} \code{start}, \code{Predicate<T>} \code{goal}, \code{Boolean} \code{found}, \typeref{TNode}{} \code{end})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Predicate}{ScientificTools.Predicate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Predicate}{BeginInvoke}(\code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Predicate}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Predicate}{Invoke}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.Distribution}{ScientificTools.Probabilities.Distribution}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{MulticastDelegate}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IAsyncResult}  \methoddef{ScientificTools.Probabilities.Distribution}{BeginInvoke}(\code{AsyncCallback} \code{callback}, \code{Object} \code{object})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.Distribution}{EndInvoke}(\code{IAsyncResult} \code{result})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.Distribution}{Invoke}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.Distributions}{ScientificTools.Probabilities.Distributions}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Bernoulli}(\code{Double} \code{p})
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Exponential}(\code{Double} \code{lambda})
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Normal}(\code{Double} \code{mu}, \code{Double} \code{sigma})
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Poisson}(\code{Int32} \code{lambda})
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Uniform}(\code{Double} \code{a}, \code{Double} \code{b})
        \item[] \typeref{Distribution}{ScientificTools.Probabilities.Distribution}  \methoddef{ScientificTools.Probabilities.Distributions}{Uniform}(\code{Int32} \code{a}, \code{Int32} \code{b})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.Event<T>}{ScientificTools.Probabilities.Event`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{Event`1}{Data} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Event`1}{Probability} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.Mode<T>}{ScientificTools.Probabilities.Mode`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{T}{} \propertydef{Mode`1}{Get} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Probabilities.Mode`1}{Add}(\typeref{T}{} \code{item})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.MovingAverage}{ScientificTools.Probabilities.MovingAverage}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{MovingAverage}{Average} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{MovingAverage}{Count} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{MovingAverage}{MaxCount} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{MovingAverage}{Total} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Probabilities.MovingAverage}{Add}(\code{Double} \code{value})
        \item[] \code{String}  \methoddef{ScientificTools.Probabilities.MovingAverage}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.RandomEx}{ScientificTools.Probabilities.RandomEx}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{Random}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Probabilities.RandomEx}{Bernoulli}(\code{Double} \code{p})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{Exponential}(\code{Double} \code{lambda})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Probabilities.RandomEx}{Flip}()
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{LogNormal}(\code{Double} \code{mu}, \code{Double} \code{sigma})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{Normal}(\code{Double} \code{mu}, \code{Double} \code{sigma})
        \item[] \code{Int32}  \methoddef{ScientificTools.Probabilities.RandomEx}{Poisson}(\code{Int32} \code{lambda})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Probabilities.RandomEx}{Roulette}(\typeref{T[]}{} \code{items}, \code{Double[]} \code{values})
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Probabilities.RandomEx}{Sample}(\typeref{T[]}{} \code{items}, \code{Int32} \code{count})
        \item[] \typeref{T[]}{}  \methoddef{ScientificTools.Probabilities.RandomEx}{Sample}(\code{IList<T>} \code{items}, \code{Int32} \code{count})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Probabilities.RandomEx}{Select}(\typeref{T[]}{} \code{items})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Probabilities.RandomEx}{Select}(\code{IList<T>} \code{items})
        \item[] \code{Void}  \methoddef{ScientificTools.Probabilities.RandomEx}{Shuffle}(\typeref{T[]}{} \code{items})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{Triangular}(\code{Double} \code{low}, \code{Double} \code{high}, \code{Double} \code{mode})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{Uniform}(\code{Double} \code{a}, \code{Double} \code{b})
        \item[] \code{Int32}  \methoddef{ScientificTools.Probabilities.RandomEx}{Uniform}(\code{Int32} \code{a}, \code{Int32} \code{b})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomEx}{VonMisses}(\code{Double} \code{mu}, \code{Double} \code{kappa})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Probabilities.RandomVariable}{ScientificTools.Probabilities.RandomVariable}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{RandomVariable}{ScientificTools.Probabilities.RandomVariable}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Bernoulli}(\code{Double} \code{p})
        \item[] \typeref{RandomVariable}{ScientificTools.Probabilities.RandomVariable}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Exponential}(\code{Double} \code{lambda})
        \item[] \code{Double}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Next}()
        \item[] \typeref{RandomVariable}{ScientificTools.Probabilities.RandomVariable}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Poisson}(\code{Int32} \code{lambda})
        \item[] \typeref{RandomVariable}{ScientificTools.Probabilities.RandomVariable}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Uniform}(\code{Double} \code{a}, \code{Double} \code{b})
        \item[] \typeref{RandomVariable}{ScientificTools.Probabilities.RandomVariable}  \methoddef{ScientificTools.Probabilities.RandomVariable}{Uniform}(\code{Int32} \code{a}, \code{Int32} \code{b})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Csv.CsvFile}{ScientificTools.Reporting.Csv.CsvFile}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Report}{ScientificTools.Reporting.Report}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Csv.CsvFile}{Add}(\typeref{CsvMatrix}{ScientificTools.Reporting.Csv.CsvMatrix} \code{csvMatrix})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Csv.CsvMatrix}{ScientificTools.Reporting.Csv.CsvMatrix}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ReportElement}{ScientificTools.Reporting.ReportElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Csv.CsvMatrix}{Generate}(\code{TextWriter} \code{output})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Matlab.MatlabElement}{ScientificTools.Reporting.Matlab.MatlabElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ReportElement}{ScientificTools.Reporting.ReportElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Matlab.MatlabFile}{ScientificTools.Reporting.Matlab.MatlabFile}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Report}{ScientificTools.Reporting.Report}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Matlab.MatlabFile}{AddItem}(\typeref{MatlabElement}{ScientificTools.Reporting.Matlab.MatlabElement} \code{element})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Matlab.MatlabVector}{ScientificTools.Reporting.Matlab.MatlabVector}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{MatlabElement}{ScientificTools.Reporting.Matlab.MatlabElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Matlab.MatlabVector}{Generate}(\code{TextWriter} \code{output})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Report}{ScientificTools.Reporting.Report}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ReportCollection}{ScientificTools.Reporting.ReportCollection}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Reporting.Report}{Generate}()
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Report}{Generate}(\code{String} \code{filename})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.ReportCollection}{ScientificTools.Reporting.ReportCollection}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ReportElement}{ScientificTools.Reporting.ReportElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.ReportCollection}{Generate}(\code{TextWriter} \code{output})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Reporting.ReportCollection}{GetEnumerator}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.ReportElement}{ScientificTools.Reporting.ReportElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.ReportElement}{Generate}(\code{TextWriter} \code{output})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Tex.TexDocument}{ScientificTools.Reporting.Tex.TexDocument}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Report}{ScientificTools.Reporting.Report}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Tex.TexEnvironment}{ScientificTools.Reporting.Tex.TexEnvironment}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{TextElement}{ScientificTools.Reporting.Tex.TextElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{String} \propertydef{TexEnvironment}{Label} \code{\{ get; \}}
        \item[] \code{String} \propertydef{TexEnvironment}{Name} \code{\{ get; \}}
        \item[] \code{Boolean} \propertydef{TexEnvironment}{Starred} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Reporting.Tex.TextElement}{ScientificTools.Reporting.Tex.TextElement}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{ReportCollection}{ScientificTools.Reporting.ReportCollection}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Reporting.Tex.TextElement}{AddContent}(\typeref{TextElement}{ScientificTools.Reporting.Tex.TextElement} \code{element})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Scanner}{ScientificTools.Scanner}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{String}  \methoddef{ScientificTools.Scanner}{Next}()
        \item[] \code{Boolean}  \methoddef{ScientificTools.Scanner}{NextBool}()
        \item[] \code{Decimal}  \methoddef{ScientificTools.Scanner}{NextDecimal}()
        \item[] \code{Double}  \methoddef{ScientificTools.Scanner}{NextDouble}()
        \item[] \code{Single}  \methoddef{ScientificTools.Scanner}{NextFloat}()
        \item[] \code{Int32}  \methoddef{ScientificTools.Scanner}{NextInt}()
        \item[] \code{String}  \methoddef{ScientificTools.Scanner}{NextLine}()
        \item[] \code{Int64}  \methoddef{ScientificTools.Scanner}{NextLong}()
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Int32} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Double} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Single} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Int64} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Boolean} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{String} \code{x})
        \item[] \typeref{Scanner}{ScientificTools.Scanner}  \methoddef{ScientificTools.Scanner}{Read}(\code{Decimal} \code{x})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Serializer}{ScientificTools.Serializer}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Boolean} \propertydef{Serializer}{OverrideExistingFiles} \code{\{ get; set \}}
        \item[] \code{String} \propertydef{Serializer}{PathPrefix} \code{\{ get; set \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Serializer}{Deserialize}(\code{Stream} \code{stream}, \typeref{Serializer.Format}{ScientificTools.Serializer+Format} \code{format})
        \item[] \typeref{T}{}  \methoddef{ScientificTools.Serializer}{Deserialize}(\code{String} \code{filename}, \typeref{Serializer.Format}{ScientificTools.Serializer+Format} \code{format})
        \item[] \typeref{IContext}{ScientificTools.IContext}  \methoddef{ScientificTools.Serializer}{OpenContext}()
        \item[] \code{Void}  \methoddef{ScientificTools.Serializer}{Serialize}(\typeref{T}{} \code{item}, \code{Stream} \code{stream}, \typeref{Serializer.Format}{ScientificTools.Serializer+Format} \code{format})
        \item[] \code{Void}  \methoddef{ScientificTools.Serializer}{Serialize}(\typeref{T}{} \code{item}, \code{String} \code{filename}, \typeref{Serializer.Format}{ScientificTools.Serializer+Format} \code{format})
    \typedefend
%--------------------------------------------------
    Enum \typedef{ScientificTools.Serializer.Format}{ScientificTools.Serializer+Format}
        \item[Members]
        \item[] \code{Binary}
        \item[] \code{Soap}
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent}{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{DiscreteEvent}{CreationTime} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{DiscreteEvent}{TimeStamp} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent}{CompareTo}(\typeref{DiscreteEvent}{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent} \code{other})
        \item[] \code{String}  \methoddef{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Simulation.DiscreteEvents.DiscreteEventArgs}{ScientificTools.Simulation.DiscreteEvents.DiscreteEventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \code{EventArgs}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{DiscreteEvent}{ScientificTools.Simulation.DiscreteEvents.DiscreteEvent} \propertydef{DiscreteEventArgs}{CurrentEvent} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{DiscreteEventArgs}{CurrentTime} \code{\{ get; \}}
        \item[] \code{Int32} \propertydef{DiscreteEventArgs}{EventsInQueue} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Simulation.DiscreteEvents.DiscreteEventsSimulator}{ScientificTools.Simulation.DiscreteEvents.DiscreteEventsSimulator}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Double} \propertydef{DiscreteEventsSimulator}{CurrentTime} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{DiscreteEventsSimulator}{LastTime} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{DiscreteEventsSimulator}{NextTime} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Boolean}  \methoddef{ScientificTools.Simulation.DiscreteEvents.DiscreteEventsSimulator}{NextEvent}()
        \item[] \code{Void}  \methoddef{ScientificTools.Simulation.DiscreteEvents.DiscreteEventsSimulator}{Run}(\code{Double} \code{time})
        \item[] \code{Void}  \methoddef{ScientificTools.Simulation.DiscreteEvents.DiscreteEventsSimulator}{Run}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Simulation.DiscreteEvents.IEventProcessor<T>}{ScientificTools.Simulation.DiscreteEvents.IEventProcessor`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Simulation.DiscreteEvents.IEventProcessor`1}{Process}(\typeref{T}{} \code{ev})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.Compare}{ScientificTools.Sorting.Compare}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Int32}  \methoddef{ScientificTools.Sorting.Compare}{Default}(\typeref{T}{} \code{x}, \typeref{T}{} \code{y})
        \item[] \code{Int32}  \methoddef{ScientificTools.Sorting.Compare}{Inverse}(\typeref{T}{} \code{x}, \typeref{T}{} \code{y})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.CountingSort}{ScientificTools.Sorting.CountingSort}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Sorter<T>}{ScientificTools.Sorting.Sorter`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.HeapSort<T>}{ScientificTools.Sorting.HeapSort`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Sorter<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.ISorter<T>}{ScientificTools.Sorting.ISorter`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] Not Available
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.ISorter`1}{Sort}(\typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Int32} \code{end}, \code{Comparison<T>} \code{comparison})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.MergeSort<T>}{ScientificTools.Sorting.MergeSort`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Sorter<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.MinimumSort<T>}{ScientificTools.Sorting.MinimumSort`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Sorter<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.QuickSort<T>}{ScientificTools.Sorting.QuickSort`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Base] \typeref{Sorter<T>}{}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.Sorter<T>}{ScientificTools.Sorting.Sorter`1}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorter`1}{Sort}(\typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Int32} \code{end}, \code{Comparison<T>} \code{comparison})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Sorting.Sorters}{ScientificTools.Sorting.Sorters}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Func<T,TResult>} \code{key})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Func<T,TResult>} \code{key})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Int32} \code{length}, \code{Func<T,TResult>} \code{key})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Comparison<T>} \code{comparison})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Comparison<T>} \code{comparison})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{IComparer<T>} \code{comparer})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{IComparer<T>} \code{comparer})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Int32} \code{length}, \code{IComparer<T>} \code{comparer})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start})
        \item[] \code{Void}  \methoddef{ScientificTools.Sorting.Sorters}{Sort}(\typeref{ISorter<T>}{} \code{sorter}, \typeref{T[]}{} \code{items}, \code{Int32} \code{start}, \code{Int32} \code{length})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Vector}{ScientificTools.Vector}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \code{Int32} \propertydef{Vector}{Dimension} \code{\{ get; set \}}
        \item[] \code{Double[]} \propertydef{Vector}{Elements} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Vector}{Item} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{Vector}{Item} \code{\{ get; set \}}
        \item[] \typeref{Vector}{ScientificTools.Vector} \propertydef{Vector}{Item} \code{\{ get; set \}}
        \item[] \code{Double} \propertydef{Vector}{Length} \code{\{ get; \}}
        \item[] \code{Double} \propertydef{Vector}{LengthSquared} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Add}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Add}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Vector}{AsColumn}()
        \item[] \typeref{Matrix}{ScientificTools.Matrix}  \methoddef{ScientificTools.Vector}{AsRow}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Clone}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Complement}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Complement}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{ComponentDivide}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{ComponentEquals}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{ComponentMultiply}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Concat}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \code{Double}  \methoddef{ScientificTools.Vector}{DistanceSqrTo}(\typeref{Vector}{ScientificTools.Vector} \code{vector})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Divide}(\code{Double} \code{scalar})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Divide}(\typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{Double} \code{scalar})
        \item[] \code{Double}  \methoddef{ScientificTools.Vector}{Dot}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Vector}{Equals}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \code{Boolean}  \methoddef{ScientificTools.Vector}{Equals}(\code{Object} \code{obj})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{FirstNegative}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{FirstPositive}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{FirstZero}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \code{IEnumerator<T>}  \methoddef{ScientificTools.Vector}{GetEnumerator}()
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{GetHashCode}()
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Modulate}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Modulate}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Multiply}(\code{Double} \code{scalar})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Multiply}(\typeref{Vector}{ScientificTools.Vector} \code{vector}, \code{Double} \code{scalar})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Multiply}(\typeref{Vector}{ScientificTools.Vector} \code{vector}, \typeref{Matrix}{ScientificTools.Matrix} \code{matrix})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Multiply}(\typeref{Matrix}{ScientificTools.Matrix} \code{matrix}, \typeref{Vector}{ScientificTools.Vector} \code{vector})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{NumberOfNegatives}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{NumberOfPositives}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \code{Int32}  \methoddef{ScientificTools.Vector}{NumberOfZeros}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Signs}(\typeref{Vector}{ScientificTools.Vector} \code{v})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Subtract}(\typeref{Vector}{ScientificTools.Vector} \code{other})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector}{Subtract}(\typeref{Vector}{ScientificTools.Vector} \code{left}, \typeref{Vector}{ScientificTools.Vector} \code{right})
        \item[] \code{Double}  \methoddef{ScientificTools.Vector}{Swap}(\code{Int32} \code{index}, \code{Double} \code{value})
        \item[] \code{String}  \methoddef{ScientificTools.Vector}{ToString}()
        \item[] \code{String}  \methoddef{ScientificTools.Vector}{ToString}(\code{Int32} \code{digits})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Vector.Builder}{ScientificTools.Vector+Builder}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vector+Builder}{Build}()
        \item[] \code{String}  \methoddef{ScientificTools.Vector+Builder}{ToString}()
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Vector.ComponentWiseOperator}{ScientificTools.Vector+ComponentWiseOperator}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Vectors}{ScientificTools.Vectors}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Canonical}(\code{Int32} \code{dimension}, \code{Int32} \code{index})
        \item[] \code{IEnumerable<T>}  \methoddef{ScientificTools.Vectors}{CanonicalBase}(\code{Int32} \code{dimension})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Ones}(\code{Int32} \code{dimension})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Orthogonal}(\typeref{Vector[]}{ScientificTools.Vector[]} \code{vectors})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Random}(\code{Int32} \code{dimension})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Random}(\code{Int32} \code{dimension}, \code{Int32} \code{digits})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Random}(\code{Int32} \code{dimension}, \code{Random} \code{random})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Random}(\code{Int32} \code{dimension}, \code{Int32} \code{digits}, \code{Random} \code{random})
        \item[] \typeref{Vector}{ScientificTools.Vector}  \methoddef{ScientificTools.Vectors}{Zeros}(\code{Int32} \code{dimension})
    \typedefend
%--------------------------------------------------
    \typedef{ScientificTools.Wildcard}{ScientificTools.Wildcard}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Properties]
        \item[] \typeref{Wildcard}{ScientificTools.Wildcard} \propertydef{Wildcard}{Get} \code{\{ get; \}}
%- - - - - - - - - - - - - - - - - - - - - - - - - -
        \item[Methods]
    \typedefend
%==================================================
