<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ExpressionsGrammar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: d5e7ce436666e7d4a2eeb12e7f8261dacceb3565 */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

.markdown-body img {
  max-width: 100%
}
</style>

</head>
<body>
<h1>SciSharp - Example: Expressions Grammar</h1>
<p>This example shows how to create an expressions grammar using 
SciSharp formal languages processing tools, and build an LR 
parser to evaluate simple arithmetic expressions. 
The source code for this example is located in the folder 
<code>Examples/ExpressionsGrammar</code> in the root of the SciSharp distribution
folder.</p>
<p>The project consists of a console application with the grammar definition,
parser building, and a simple loop that reads a line from the standard
input and parses and evaluates the expression.</p>
<h2>Definition of the grammar</h2>
<p>The grammar is defined using the SciSharp grammars embedded DSL. The full definition is listed here:</p>
<pre><code>// Definition of the grammar
var G = new Grammar&lt;ExpressionNode&gt;();

// Definition of Non-terminals
Def&lt;ExpressionNode&gt; E = G.Start(&quot;E&quot;); // Names are for debugging reasons
Def&lt;ExpressionNode&gt; T = G.Rule(&quot;T&quot;);
Def&lt;ExpressionNode&gt; F = G.Rule(&quot;F&quot;);

// Definition of Tokens
Token&lt;ExpressionNode&gt; add = G.Token('+'); // You can define char tokens
Token&lt;ExpressionNode&gt; sub = G.Token('-');
Token&lt;ExpressionNode&gt; mul = G.Token('*');
Token&lt;ExpressionNode&gt; div = G.Token('/');
Token&lt;ExpressionNode&gt; lp = G.Token('(');
Token&lt;ExpressionNode&gt; rp = G.Token(')');
Token&lt;ExpressionNode&gt; cons = G.Token(&quot;const&quot;, @&quot;[123456789]\d*&quot;);
// You can also define tokens by regexes
// The name is for debugging purposes

// Definition of productions

// Semantic rules defined by using the parameters list
// p[0] is the reduced (left-hand) symbol
// p[1], p[2], ..., are the right-hand symbols
// Note that p[2] is the 'plus' token
E %= (E + add + T).With((p, node) =&gt; node.Value = p[1].Value + p[3].Value) |
     (E + sub + T).With((p, node) =&gt; node.Value = p[1].Value - p[3].Value) |
     (T).With((p, node) =&gt; node.Value = p[1].Value);

// Semantic rules defined using the symbol directly
// x is the resulting Node instance
// Notice that refering to 'T' is not ambiguous, the parser
// will prefer the right-hand 'T'.
T %= (T + mul + F).With(x =&gt; x.Value = T.Node.Value*F.Node.Value) |
     (T + div + F).With(x =&gt; x.Value = T.Node.Value/F.Node.Value) |
     (F).With(x =&gt; x.Value = F.Node.Value);

// Semantic rules defined using the Ref() tool
Ref&lt;ExpressionNode&gt; e = G.Ref();
F %= (lp + E + rp).With(x =&gt; x.Value = E.Node.Value) |
     (cons).With(x =&gt; x.Value = Convert.ToDouble(cons.Regex));
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
