\sct\footnote{Although official named Sci$\sharp$, for ASCII compatibility
we will write the name as \sct, as it is the name used in the
rest of the documentation and all web-based content, to avoid using
the non-ascii $\sharp$ character, or worse, the \# character, which
is used to define anchors in URLs.} is a \cs library for scientific computing applications.
It contains a set of frameworks for a number of areas of scientific
computing, such as optimization, simulation, graph searching, 
probabilities and statistics, language processing, numerical algorithms,
computational geometry and number theory. It also provides tools for
testing and comparison of algorithms and for the generation of 
reports in several formats.

The main goal of \sct is to provide a set of tools for
the scientific community to develop algorithms in .NET for 
a very broad range of applications. Despite
being written entirely in \cs it aims to provide efficient
implementations, based on parallel, distributed and GPU programming
techniques.

Scientific computing is a very broad term which, for us, encompasses
the algorithms, frameworks and computational tools used by scientists in 
many different areas to solve domain-specific problems. It goes
from numerics to optimization, from statistics to machine learning,
from string matching to natural language processing, and so on.
We focus on a very narrow area of scientific computing, that is,
scientific computing for computer scientists. We say very narrow because
even if it is a big area (almost everything in computer science can
be fit into the definition of scientific computing -- notice the
names resemblance), it does not contains specific tools or
techniques employed for instance by physicists, chemists, biologists 
and other scientists. That said, many of the tools provided
in \sct are of use for scientists of these areas. Physicists and
chemists often use numerical simulation techniques to model
processes, and biologists are among the most assiduous users
(and developers) of string matching techniques.

Although tailored for the scientist, \sct is also of use
for developers not much into science, but who want to provide some
``advanced'' features in their products which may require
techniques extracted from the computer science world.

This book provides a very shallow introduction to some
scientific computing topics, using the \sct library. 
We have found out, through 
teaching many of these topics to computer science students,
that most of times a better understanding can be obtained by going
first through a practical introduction, dive quickly into the
corresponding algorithms, and then, when hunger rises, search
for the solid theoretical background. This book aims to guide in
the first two steps, and then provide links to more advanced 
bibliography for those interested in the third step. 
For this reason, we will most
of the time state things loosely (without a formal proof) and
just point out in the direction where a formal proof can be found.

We will also not focus on the implementation details of the 
presented techniques. First of all, implementation details are,
well, details, and a different implementation can have very different
issues, so we see no point in discussing particularities of our
own implementation. We will focus a lot more into how to use the
presented tools for solving interesting problems, that into how the
tools themselves are implemented. We will present
the algorithms and data structures just with the necessary detail
so that the reader can understand (at least intuitively) how and
why they work. In any case, all the nasty details can be obtained by reading
the source code for \sct. 

We are targeting two types of audiences with this book, both computer
science students and professional of other areas who are interested
in applying these techniques to their own problems. For computer scientists
who have already mastered the techniques described here the book will
seem overly simple. However, we think that students looking for a
digestible introduction to some advanced techniques may find it handy.
This is our intended audience in the computer science world. We seek only
to provide the first few pushes necessary to get you on the track for
more advanced material. Returners from the industry who have forgotten the basis of
these techniques can also find the book useful to dig out that
long ago hidden knowledge. 
For professional of other areas, we aim to provide a very practical 
approach, showing how to apply the presented techniques to real-life
problems. And in the meantime, we also show how to use a specific
framework in a specific programming language that can get the job
done.

For these reasons, there are at least two ways to read the book\footnote{There
are in fact $N!$ ways of reading it, where $N$ is the number of letters
in the book, but most of them are of no use.}.
for those interested in achieving a working understanding of the
algorithms and techniques presented, the first few sections of every
chapter will provide some theoretical background. For those interested
in just getting the job done, we will provide whenever useful links
to the practical sections, where we show show how to use \sct to
solve the corresponding problems. Watch out for the \emph{cut to the chase}
\cuttothechase{listing:hello-word}{Hello World!}
links on the margin (if you have an electronic (PDF) version of the book,
it should be hyper-linked, so try clicking anything that seems interesting).
They provide a quick jump to the ``implementation area'' of the corresponding
topic.

%========================================================================
\section*{Prerequisites}
\addcontentsline{toc}{section}{Prerequisites}
%========================================================================

\sct is a library written in C\# for scientific computing. As
such, this manual considers on behalf of the reader a working
understanding both of the C\# language.

The algorithms and data structures implemented in the library
are in most cases well known in the scientific community.
In such cases, the first time a given algorithm, data structure
or any other important concept is mentioned in this manual, a
reference will be provided to the corresponding 
\href{http://en.wikipedia.org}{Wikipedia} page. All non-standard
modifications will be explained in detail proportional to
how strange or new is the given modification, and when possible
references will be provided from the corresponding papers or
websites.

%========================================================================
\section*{About the Source Code}
\addcontentsline{toc}{section}{About the Source Code}
%========================================================================

All code used throughout the book is written in C\#, adhering
to the style used in by the developers of the library. Being a 
.NET library, all functionality can be used in any CLR compliant
language. Most the examples used in the manual are shipped
with the source code for the library. 
Source code will be formatted in \verb|monospace| font, with
the corresponding syntax highlight.

The \sct library has been designed following modern
design patterns and coding styles. Throughout the library we have
tried to be consistent with a unified style, which will be used in
the code examples for this manual. Being a scientific library, we
have tried also to provide support for some flavoured syntax styles
widely used in some scientific packages, such as Matlab and Octave.
We have also tried to supply a syntax as close as possible to that
used by academicians in the corresponding areas.

We have implemented this syntax sugar with heavy use of operators
overloading and other fluid interfaces techniques. This means 
that there are almost always two ways of doing things, with
the usual C\# syntax (dot notation and such) and with the flavoured
syntax which may involve using some strange operators and 
method names, in order to get a code that looks familiar
to the mathematician eye. 

We have designed the library this way because we feel it is
more natural for the scientist, but it could be weird for the
programmer used to the clean dot notation syntax. If you ever
feel uncomfortable using the flavoured syntax, you can
always find a way of doing the same thing using standard
C\# syntax. 

We particularly prefer the syntax sugar
\footnote{There is a common joke that says: \emph{Syntax sugar
causes cancer of the semicolon}.} whenever possible, because
we designed the library this way, it has become a
common language for the library developers, and in the code examples
you'll find it anywhere. In any case, in this manual we will
always provide hints of how to circumvent the syntax sugar
in favour of a more \cs-ist syntax.

We now provide the classic ``Hello Word'' algorithm in \cs for
the weak of heart.\label{listing:hello-world}

\begin{verbatim}
using Sytem;

namespace HelloWorld
{
    public static class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");        
        }    
    }
}
\end{verbatim}

%========================================================================
\section*{What this Manual Is Not}
\addcontentsline{toc}{section}{What this Manual Is Not}
%========================================================================

This manual is \textbf{not} a reference for algorithms and
data structures. You will not find implementation details for the
algorithms, nor proves of asymptotic complexity, or any other
theoretical details of the implemented tools, other than the very
basic definitions.

This manual does \textbf{not} explain which algorithm or technique
is better in which case, nor provides comparisons between algorithms 
other than (perhaps) some information about our particular implementation
that we think you may need to know. For instance, we will never say
that \emph{QuickSort} is faster than \emph{MergeSort} (well, I just did, but
that is not the point). We could say, however, that \textbf{our} \emph{QuickSort}
implementation is faster than \textbf{our} \emph{MergeSort} implementation.

You \textbf{will} find, however, links to
relevant places where you can start doing some research
about the techniques implemented. You can also look at the
source code in any moment, where you'll find all implementation
details you want (is all in there, isn't it?). Also, the
examples have been designed trying to choose interesting or at least
classic problems that can be solved using the corresponding
techniques. 

But always keep in mind that we are just giving you
a hammer, it is your choice how to use it: to build a house,
to bake some cookies, or to break someone's head. The examples
we provide will almost always be about house building, in fewer
cases about cooking, but \emph{almost} never about head smashing. 